<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[RRRay]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://potatoker.github.io/"/>
  <updated>2016-08-17T07:19:05.740Z</updated>
  <id>http://potatoker.github.io/</id>
  
  <author>
    <name><![CDATA[RRRay]]></name>
    <email><![CDATA[kknightgo@gmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[动态加载任务并行框架]]></title>
    <link href="http://potatoker.github.io/2016/08/17/%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%B9%B6%E8%A1%8C%E6%A1%86%E6%9E%B6/"/>
    <id>http://potatoker.github.io/2016/08/17/动态加载任务的并行框架/</id>
    <published>2016-08-17T07:10:01.000Z</published>
    <updated>2016-08-17T07:19:05.740Z</updated>
    <content type="html"><![CDATA[<p>项目已经过去很久了，虽然现在研究方向改变了很多，但是从毕设开始做这个到发现这个和目前流行的一些插件化原理很相似，这里再基于之前做的和之后学到的内容对动态加载做一个总结。</p>
<a id="more"></a>
<p>先介绍本来这个项目的机制:</p>
<ol>
<li>并行框架采用了AKKA,目前已经实现了AKKA框架在Android平台上的运行了，但遇到了Mthod 64K的问题，使用multidex的方法在Android5.0的平台上得到了解决</li>
<li>master向集群中的slave发送dex格式或者经过dx工具转换过的jar文件，然后slave执行这些文件或这些文件中的部分代码:<ol>
<li>发送只含有main函数的.dex文件:有些任务比较简单，一个main函数就能搞定，执行他们只需要像在pc上执行java命令一样，不过这里在安卓上，是使用dalvik命令</li>
<li>发送转换过的jar文件(其实和上面的.dex文件用的是同一个转换工具，同一个转换命令只是output的文件格式不同)，slave的程序中动态的加载这个jar里面的class来使用，执行。</li>
</ol>
</li>
</ol>
<h2 id="1-__u76F4_u63A5_u6267_u884C_u7684_u4EFB_u52A1"><a href="#1-__u76F4_u63A5_u6267_u884C_u7684_u4EFB_u52A1" class="headerlink" title="1. 直接执行的任务"></a>1. 直接执行的任务</h2><p>这个时候在服务器端，用对应的命令把一个project打包成dex，然后把对应的dex文件发送给集群中待命的slave,slave收到了dex文件后，使用Java的process builder类创建子进程，子进程执行的命令是dalvik命令，就和java命令可以执行jar一样，dalvik命令可以执行dex中的main函数。</p>
<pre><code>dx.bat --dex --output = output.jar input.jar
</code></pre><p>不过实际上我自己的毕设中用的是.dex格式:</p>
<pre><code>dx --dex --output=matrixTime.dex matrixTime.jar
</code></pre><p>另,不过看到<a href="http://stackoverflow.com/questions/27349097/load-dex-file-dynamically-on-android-5-0" target="_blank" rel="external">有人</a>说生成dex格式的在5.0以后使用classLoader有问题，所以统一成了jar文件,<a href="http://stackoverflow.com/questions/4163167/convert-class-file-to-dex-file" target="_blank" rel="external">有人</a>解释清楚了不管是直接执行还是classloader都可以用jar的。</p>
<p>然后使用dalvik 命令执行这个dex文件里的main函数:</p>
<pre><code>/system/bin/dalvikvm -cp /data/data/edu.mit.haoqili.file_transfer/test/Hello.dex hello.Hello
</code></pre><p>通过:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">proc=Runtime.getRuntime().exec(<span class="string">"su"</span>);</span><br><span class="line">String cmd3=<span class="string">"/system/bin/dalvikvm -cp "</span>+dexPath+<span class="string">" "</span>+className;</span><br><span class="line"></span><br><span class="line">Log.i(<span class="string">"cmd3 "</span>,cmd3);</span><br><span class="line">os = <span class="keyword">new</span> DataOutputStream(proc.getOutputStream());</span><br><span class="line">os.writeBytes(cmd3 + <span class="string">"\n"</span>);</span><br><span class="line">os.writeBytes(<span class="string">"exit\n"</span>);</span><br><span class="line">os.flush();</span><br></pre></td></tr></table></figure>
<p>来向这个子进程输入这个命令<br>通过：<code>java.io.InputStream is=proc.getInputStream();</code>来得到运行结果</p>
<h3 id="DVM_u548CJVM_u7684_u533A_u522B"><a href="#DVM_u548CJVM_u7684_u533A_u522B" class="headerlink" title="DVM和JVM的区别"></a>DVM和JVM的区别</h3><p>DVM是基于寄存器的虚拟机，JVM是基于栈的虚拟机</p>
<p>看一下这个，一行普通的C代码:</p>
<pre><code>a = b + c;  
</code></pre><p>把他变成汇编语言:</p>
<pre><code>add a, b, c 
</code></pre><p>那看起来就更像机器指令了，对吧？这种就是所谓“三地址指令”（3-address instruction），一般形式为：</p>
<pre><code>op dest, src1, src2 
</code></pre><p>许多操作都是二元运算+赋值。三地址指令正好可以指定两个源和一个目标，能非常灵活的支持二元操作与赋值的组合。ARM处理器的主要指令集就是三地址形式的。 </p>
<blockquote>
<p>三地址与二地址形式的指令集，一般就是通过“基于寄存器的架构”来实现的。例如典型的RISC架构会要求除load和store以外，其它用于运算的指令的源与目标都要是寄存器。 </p>
</blockquote>
<p>有没有0地址的指令呢，有的，同样的上面的代码翻译过来:</p>
<pre><code>iconst_1  
iconst_2  
iadd  
istore_0 
</code></pre><p>其实现依赖于一种常见的数据结构——没错，就是栈。上面的iconst_1、iconst_2两条指令，分别向一个叫做“求值栈”（evaluation stack，也叫做operand stack“操作数栈”或者expression stack“表达式栈”）的地方压入整型常量1、2。iadd指令则从求值栈顶弹出2个值，将值相加，然后把结果压回到栈顶</p>
<blockquote>
<p>零地址形式的指令集一般就是通过“基于栈的架构”来实现的</p>
</blockquote>
<p>零地址指令的“密度”可以非常高——可以用更少空间放下更多条指令。因此在空间紧缺的环境中，零地址指令是种可取的设计。但零地址指令要完成一件事情，一般会比二地址或者三地址指令许多更多条指令.</p>
<p>总之就是，基于栈的架构指令会占用较少的内存空间，但完成操作需要更多的load/store指令，也意味着更多的指令分派（instruction dispatch）次数与内存访问次数</p>
<p><strong>所以一般认为基于寄存器的架构对VM来说也是更快的</strong></p>
<p>那么回到正题，DVM就是基于寄存器的，JVM是基于栈的。</p>
<p>为什么JVM要基于栈呢?</p>
<ol>
<li>实现简单<br>由于指令中不必显式指定源与目标，VM可以设计得很简单，不必考虑为临时变量分配空间的问题，求值过程中的临时数据存储都让求值栈包办就行。 </li>
<li>该VM是为某类资源非常匮乏的硬件而设计的<br>这类硬件的存储器可能很小，每一字节的资源都要节省。零地址指令比其它形式的指令更紧凑，所以是个自然的选择。 </li>
<li>考虑到可移植性<br>如果一个VM采用基于栈的架构，则无论在怎样的实际机器上，都很好实现——它的源架构里没有任何通用寄存器，所以实现VM时可以比较自由的分配实际机器的寄存器。于是这样的VM可移植性就比较高</li>
</ol>
<p>但DVM的寄存器是虚拟寄存器:</p>
<blockquote>
<p>与JVM相似，在Dalvik VM中每个线程都有自己的PC和调用栈，方法调用的活动记录以帧为单位保存在调用栈上。PC记录的是以16位为单位的偏移量而不是以字节为单位的。<br>与JVM不同的是，Dalvik VM的栈帧中没有局部变量区与求值栈，取而代之的是一组虚拟寄存器。每个方法被调用时都会得到自己的一组虚拟寄存器。</p>
</blockquote>
<p>到此为止，两者各有好处，再深入就hold不住了。更详细的额关于编译器，解释器的内容在<a href="http://rednaxelafx.iteye.com/blog/492667" target="_blank" rel="external">这里</a>非常好的文章。</p>
<h2 id="2-calss_u6587_u4EF6_u4F5C_u4E3A_u4EFB_u52A1_u5355_u4F4D"><a href="#2-calss_u6587_u4EF6_u4F5C_u4E3A_u4EFB_u52A1_u5355_u4F4D" class="headerlink" title="2.calss文件作为任务单位"></a>2.calss文件作为任务单位</h2><p>这就要用到dynamic class loading了</p>
<p>如何理解的dynamic class loading了:</p>
<blockquote>
<p>there are situations where custom class loading can come in handy. Here are a couple of scenarios:</p>
<ul>
<li>Big apps can contain more than 64K method references, which is the maximum number of supported in a dex file. To get around this limitation, developers can partition part of the program into multiple secondary dex files, and load them at runtime.</li>
<li>Frameworks can be designed to make their execution logic extensible by dynamic code loading at runtime.</li>
</ul>
</blockquote>
<p>也许我上面这个需求算是第二个需求了吧</p>
<p>在说这个项目相关之前，来看看介绍andorid dynamic class loader的例子吧:</p>
<p>完整的在<a href="http://dsgwords.blogspot.com/2013/03/android-runtime-class-loading.html" target="_blank" rel="external">这里</a></p>
<ol>
<li><p>把要执行的input.jar 转换成可以被dalvik load的outpu.jar：</p>
<pre><code>On Windows: dx.bat --dex --output = output.jar input.jar
</code></pre></li>
<li><p>生成相应的classLoader:</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String dexFile = <span class="string">"/output.jar"</span>;</span><br><span class="line">File f = <span class="keyword">new</span> File(Environment.getExternalStorageDirectory().toString() + dexFile);</span><br><span class="line"><span class="keyword">final</span> File optimizedDexOutputPath = getDir(<span class="string">"outdex"</span>, <span class="number">0</span>);</span><br><span class="line">DexClassLoader classLoader = <span class="keyword">new</span> DexClassLoader(f.getAbsolutePath(),</span><br><span class="line">optimizedDexOutputPath.getAbsolutePath(),<span class="keyword">null</span>, getClassLoader());</span><br></pre></td></tr></table></figure>
<p>上面就是为了使用classLoader的loadclass函数得到class对象:<br><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">Class</span>&lt;?&gt; <span class="title">myClass</span> = <span class="title">classLoader</span>.<span class="title">loadClass</span>(<span class="title">completeClassName</span>);</span></span><br></pre></td></tr></table></figure></p>
<p>然后通过反射调生成该类的对象以及用其中的函数:</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = (Object)myClass.newInstance();</span><br><span class="line">   <span class="function"><span class="keyword">Method</span> <span class="title">m</span> = <span class="title">myClass</span>.<span class="title">getMethod</span><span class="params">(methodToInvoke)</span>;</span></span><br><span class="line">   m.invoke(obj);</span><br></pre></td></tr></table></figure>
<p>首先看一看函数:</p>
<pre><code>DexClassLoader (String dexPath, 
            String optimizedDirectory, 
            String librarySearchPath, 
            ClassLoader parent)
</code></pre><blockquote>
<p>Parameters</p>
<ul>
<li>dexPath<br>String: the list of jar/apk files containing classes and resources, delimited by File.pathSeparator, which defaults to”:” on Android</li>
<li>optimizedDirectory<br>String: directory where optimized dex files should be written; must not be null</li>
<li>librarySearchPath<br>String: the list of directories containing native libraries, delimited by File.pathSeparator; may be null</li>
<li>parent<br>ClassLoader: the parent class loader</li>
</ul>
</blockquote>
<ul>
<li>第一个参数dexPath就是要加载的jar文件的绝对路径，这里可以是SD卡也可是InternalStorage.</li>
<li>第二个参数optimizedDirectory是要把读取优化的classes信息缓存的地方，这里一般是internalStorage,放在外存不安全常使用<code>File dexOutputDir = context.getCodeCacheDir();</code>来生成这个dir.</li>
</ul>
<blockquote>
<p>optimizedDirectory是用来缓存我们需要加载的dex文件的，并创建一个DexFile对象，如果它为null，那么会直接使用dex文件原有的路径来创建DexFile</p>
</blockquote>
<ul>
<li>第三个参数好像一般都是NUll</li>
<li>第四个参数是生成的classLoader的父loader，这个是一定要指定的，一般就指定当前所在类的classLoader,使用<code>getClassLoader()</code></li>
</ul>
<p>先在这里停一停，来看看classLoader这个东西</p>
<p>##3. classLoader</p>
<p>ClassLoader就是专门用来处理类加载工作的,一个运行中的APP 不仅只有一个类加载器。</p>
<ul>
<li>比如在Android系统启动的时候会创建一个Boot类型的ClassLoader实例，用于加载一些系统Framework层级需要的类</li>
<li>此外，APP也有自己的类，这些类保存在APK的dex文件里面，所以APP启动的时候，也会创建一个自己的ClassLoader实例，用于加载自己dex文件中的类</li>
<li>一个运行的Android应用至少有2个ClassLoader，一个是BootClassLoader（系统启动的时候创建的），另一个是PathClassLoader（应用启动时创建的，用于加载“/data/app/me.kaede.anroidclassloadersample-1/base.apk”里面的类）</li>
</ul>
<h3 id="3-1_DexClassLoader__u548C_PathClassLoader"><a href="#3-1_DexClassLoader__u548C_PathClassLoader" class="headerlink" title="3.1 DexClassLoader 和 PathClassLoader"></a>3.1 DexClassLoader 和 PathClassLoader</h3><p>在Android中，ClassLoader是一个抽象类，实际开发过程中，我们一般是使用其具体的子类DexClassLoader、PathClassLoader这些类加载器来加载类的，它们的不同之处是：</p>
<ul>
<li>DexClassLoader可以加载jar/apk/dex，可以从SD卡中加载未安装的apk；</li>
<li>PathClassLoader只能加载系统中已经安装过的apk；</li>
</ul>
<h4 id="3-1-1_loadClass_28_29"><a href="#3-1-1_loadClass_28_29" class="headerlink" title="3.1.1 loadClass()"></a>3.1.1 loadClass()</h4><p>JVM中ClassLoader通过defineClass方法加载jar里面的Class，而Android中这个方法被弃用了。</p>
<p>看看使用defineClass的例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class <span class="title">loadClass</span><span class="params">(String name)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="string">"reflection.MyObject"</span>.equals(name))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String url = <span class="string">"file:C:/data/projects/tutorials/web/WEB-INF/"</span> +</span><br><span class="line">                            <span class="string">"classes/reflection/MyObject.class"</span>;</span><br><span class="line">            URL myUrl = <span class="keyword">new</span> URL(url);</span><br><span class="line">            URLConnection connection = myUrl.openConnection();</span><br><span class="line">            InputStream input = connection.getInputStream();</span><br><span class="line">            ByteArrayOutputStream buffer = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> data = input.read();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(data != -<span class="number">1</span>)&#123;</span><br><span class="line">                buffer.write(data);</span><br><span class="line">                data = input.read();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            input.close();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] classData = buffer.toByteArray();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> defineClass(<span class="string">"reflection.MyObject"</span>,</span><br><span class="line">                    classData, <span class="number">0</span>, classData.length);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没错，这个例子之前就举过了。<br>Android中这个方法被弃用了而使用<code>loadClass()</code>方法。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Class</span> libProviderClazz = <span class="keyword">null</span>;</span><br><span class="line">libProviderClazz = cl.loadClass(<span class="string">"com.example.dex.lib.LibraryProvider"</span>);</span><br></pre></td></tr></table></figure>
<p>或者上面的Class&lt;?&gt;，虽然不知道这里加或者不加的区别是啥.</p>
<h4 id="3-1-2DexClassLoader__u548C_PathClassLoader_u7684_u533A_u522B"><a href="#3-1-2DexClassLoader__u548C_PathClassLoader_u7684_u533A_u522B" class="headerlink" title="3.1.2DexClassLoader 和 PathClassLoader的区别"></a>3.1.2DexClassLoader 和 PathClassLoader的区别</h4><p>PathClassLoader的构造函数:</p>
<pre><code>PathClassLoader (String dexPath, 
                ClassLoader parent)
</code></pre><blockquote>
<p>optimizedDirectory必须是一个内部存储路径，还记得我们之前说过的，无论哪种动态加载，加载的可执行文件一定要存放在内部存储。DexClassLoader可以指定自己的optimizedDirectory，所以它可以加载外部的dex，因为这个dex会被复制到内部路径的optimizedDirectory；而PathClassLoader没有optimizedDirectory，所以它只能加载内部的dex，这些大都是存在系统中已经安装过的apk里面的。</p>
</blockquote>
<h4 id="3-1-3_u52A0_u8F7D_u7C7B_u7684_u8FC7_u7A0B"><a href="#3-1-3_u52A0_u8F7D_u7C7B_u7684_u8FC7_u7A0B" class="headerlink" title="3.1.3加载类的过程"></a>3.1.3加载类的过程</h4><p>源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String className) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">      <span class="keyword">return</span> loadClass(className, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String className, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">      Class&lt;?&gt; clazz = findLoadedClass(className);</span><br><span class="line">      <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">          ClassNotFoundException suppressed = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              clazz = parent.loadClass(className, <span class="keyword">false</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">              suppressed = e;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  clazz = findClass(className);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                  e.addSuppressed(suppressed);</span><br><span class="line">                  <span class="keyword">throw</span> e;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> clazz;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>加载类的逻辑是:</p>
<ol>
<li>在自己加载类的缓存中是否已经加载过此类，如果加载过直接返回，否则2</li>
<li>parent Loader递归的调用loadClass,由父Loader去加载，父Loader加载成功的话就会返回，否则3</li>
<li>所有继承路线上的父loader都没办法加载这个类，那么才由自己来加载</li>
</ol>
<h4 id="3-1-4_Dynamic_Class_Reloading"><a href="#3-1-4_Dynamic_Class_Reloading" class="headerlink" title="3.1.4 Dynamic Class Reloading"></a>3.1.4 Dynamic Class Reloading</h4><p>之所以把这个单独拿出来，是因为之前好像看到过插件化修复Bug用到了这个dynamic class reload，可以在程序运行的时候直接修改某个需要用到的类。</p>
<p>这里唯一要注意的是，因为如果只是单纯的用同一个classLoader对象去load一个同名的class文件什么都不会发生，因为在系统看来只是重复加载。</p>
<p>解决办法也很简单，就是重新生成一个classLoader去加载即可:</p>
<blockquote>
<p>Classes will be unloaded and garbage collected like any other object, if there is no remaining reference to them. That means there must be no reachable instance of the class (as loaded by that particular classloader instance) and the classloader instance itself must be eligible for garbage collection as well.<br>So basically, all you have to do is to create a new classloader instance to load the new version of the class, and make sure that no references to instances of the old version remain.</p>
</blockquote>
<p>下面这段代码是重复加载defineClass示例代码中的MyObject.class的一个示例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span></span><br><span class="line">    ClassNotFoundException,</span><br><span class="line">    IllegalAccessException,</span><br><span class="line">    InstantiationException </span>&#123;</span><br><span class="line"></span><br><span class="line">    ClassLoader parentClassLoader = MyClassLoader.class.getClassLoader();</span><br><span class="line">    MyClassLoader classLoader = <span class="keyword">new</span> MyClassLoader(parentClassLoader);</span><br><span class="line">    Class myObjectClass = classLoader.loadClass(<span class="string">"reflection.MyObject"</span>);</span><br><span class="line"></span><br><span class="line">    AnInterface2       object1 =</span><br><span class="line">            (AnInterface2) myObjectClass.newInstance();</span><br><span class="line"></span><br><span class="line">    MyObjectSuperClass object2 =</span><br><span class="line">            (MyObjectSuperClass) myObjectClass.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//create new class loader so classes can be reloaded.</span></span><br><span class="line">    classLoader = <span class="keyword">new</span> MyClassLoader(parentClassLoader);</span><br><span class="line">    myObjectClass = classLoader.loadClass(<span class="string">"reflection.MyObject"</span>);</span><br><span class="line"></span><br><span class="line">    object1 = (AnInterface2)       myObjectClass.newInstance();</span><br><span class="line">    object2 = (MyObjectSuperClass) myObjectClass.newInstance();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，注意到这里有个interface的转型。为什么reload要用到转型呢?这个<a href="http://tutorials.jenkov.com/java-reflection/dynamic-class-loading-reloading.html" target="_blank" rel="external">作者</a>是有回答的:</p>
<blockquote>
<p>A class is identified by its fully qualified class name + the ClassLoader that loaded it.</p>
<p>A ClassLoader cannot load the same class more than once. Thus, to reload a class you must use a new ClassLoader. However, if you load the same class with a new ClassLoader, it is <em>not</em> identified as the same class as first time it was loaded with another ClassLoader. Thus, you cannot cast instances of the reloaded class directly to instances of that class. Look at this example:</p>
<p>MyObject myObject = myObjectClass.newInstance();</p>
<p>The MyObject type specified for the type of the variable will <em>not</em> be identified as the same class as myObjectClass, if they have been loaded by different ClassLoaders. The ClassLoader loading the class with the above variable declaration will also load MyObject. When you later reload MyObject with a new ClassLoader, the two classes are not the same anymore.</p>
<p>Instead you have to cast instances of the reloaded class to a type that is always loaded by the same (first) ClassLoader. That could be an interface or superclass which you never reload, but which has the same interface as you need from the reloaded classes.</p>
</blockquote>
<p>其实这里理解的有点模糊，不过，大概可以明白的是，原来的类叫MyObject,新加载的类也叫Myobject,但其实这俩根本不是同一个类，因为这俩都自己新new了一个classLoader来load，Java判断这俩根本不是同一个类，所以如果在第二次Load完想要得到一个instance的时候如果流程都直接是:</p>
<pre><code>Object1 object1 = myObjectClass.newInstance()
Object1 object_reload = myObjectClass2.newInstance()
</code></pre><p>会报:ClassCastException.我理解的是因为第一个类先load了，系统认为Object1这个类名就是第一个类，可是重新加载的是一个新的类，所以这里有强制转换的错误。</p>
<p>但是如果在写这两个类的时候让他们implement同一个接口。那么他们分别强制转换为同一个接口对象就可以正常调用了</p>
<h4 id="3-1-5__u8C03_u7528_u52A0_u8F7D_u65B9_u6CD5_u7684_u4E24_u79CD_u65B9_u5F0F"><a href="#3-1-5__u8C03_u7528_u52A0_u8F7D_u65B9_u6CD5_u7684_u4E24_u79CD_u65B9_u5F0F" class="headerlink" title="3.1.5 调用加载方法的两种方式"></a>3.1.5 调用加载方法的两种方式</h4><h5 id="3-1-5-1_interface_u65B9_u6CD5"><a href="#3-1-5-1_interface_u65B9_u6CD5" class="headerlink" title="3.1.5.1 interface方法"></a>3.1.5.1 interface方法</h5><ol>
<li>在一级dex(本来就在源程序中)中定义一个包含方法名的interface.二级dex(要load的)的要加载类要implement这个方法。</li>
<li>在Load完成之后，使用newInstance得到一个被加载类的实例，然后然后转型为上面已经定义好的interface.</li>
<li>由于已经cast成了interface，这时可以任意调用里面的方法了</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Load the library.</span></span><br><span class="line">      libProviderClazz =</span><br><span class="line">          cl.loadClass(<span class="string">"com.example.dex.lib.LibraryProvider"</span>);</span><br><span class="line">      <span class="comment">// Cast the return object to the library interface so that the</span></span><br><span class="line">      <span class="comment">// caller can directly invoke methods in the interface.</span></span><br><span class="line">      <span class="comment">// Alternatively, the caller can invoke methods through reflection,</span></span><br><span class="line">      <span class="comment">// which is more verbose. </span></span><br><span class="line">      LibraryInterface lib = (LibraryInterface) libProviderClazz.newInstance();</span><br><span class="line">      lib.showAwesomeToast(<span class="keyword">this</span>, <span class="string">"hello"</span>);</span><br></pre></td></tr></table></figure>
<p>可以看到，这里没有通过反射的方法去得到showAwesomeToast这个方法，而是直接调用了这个方法。</p>
<h5 id="3-1-5-2__u53CD_u5C04_u65B9_u6CD5"><a href="#3-1-5-2__u53CD_u5C04_u65B9_u6CD5" class="headerlink" title="3.1.5.2 反射方法"></a>3.1.5.2 反射方法</h5><p>反射可以”窥探”得到一个类里面的任何东西，当然包括方法:<br>只要获取了Class对象，就可以:</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">Method</span> <span class="title">m</span> = <span class="title">myClass</span>.<span class="title">getMethod</span><span class="params">(methodToInvoke, param1.<span class="keyword">class</span>, param2.<span class="keyword">class</span>, ...)</span>;</span></span><br><span class="line">m.invoke(obj, param1, param2, ...);</span><br></pre></td></tr></table></figure>
<p>譬如，已经通过New instance得到了对象obj：</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> msg = <span class="string">"parameter"</span>;</span><br><span class="line">Method m = <span class="keyword">myClass</span>.getMethod(methodToInvoke, <span class="built_in">String</span>.<span class="keyword">class</span>);</span><br><span class="line">m.invoke(obj, msg);</span><br></pre></td></tr></table></figure>
<p><code>m.invoke(obj, msg);</code>表示在对象上调用m方法，参数是msg.</p>
<h5 id="u4E8C_u8005_u6BD4_u8F83"><a href="#u4E8C_u8005_u6BD4_u8F83" class="headerlink" title="二者比较"></a>二者比较</h5><blockquote>
<p>The advantage of using reflection is that it doesn’t require the secondary dex file to implement any particular interfaces. However, one should be aware that reflection is verbose and slow.</p>
</blockquote>
<p>###Android程序比起一般Java程序在使用动态加载时麻烦在哪里</p>
<blockquote>
<p>通过上面的分析，我们知道使用ClassLoader动态加载一个外部的类是非常容易的事情，所以很容易就能实现动态加载新的可执行代码的功能，但是比起一般的Java程序，在Android程序中使用动态加载主要有两个麻烦的问题：</p>
<ol>
<li><p>Android中许多组件类（如Activity、Service等）是需要在Manifest文件里面注册后才能工作的（系统会检查该组件有没有注册），所以即使动态加载了一个新的组件类进来，没有注册的话还是无法工作；</p>
</li>
<li><p>Res资源是Android开发中经常用到的，而Android是把这些资源用对应的R.id注册好，运行时通过这些ID从Resource实例中获取对应的资源。如果是运行时动态加载进来的新类，那类里面用到R.id的地方将会抛出找不到资源或者用错资源的异常，因为新类的资源ID根本和现有的Resource实例中保存的资源ID对不上；</p>
</li>
</ol>
</blockquote>
<p>对应的解决方案:</p>
<h4 id="u4EE3_u7406"><a href="#u4EE3_u7406" class="headerlink" title="代理"></a>代理</h4><p>对第一个问题，网上说的比较多的就是代理的方式了，如果插件的某些方法是定义在activity里面，那么在客户端可以创建一个空壳activity，这个空壳activity没有具体的动作，但是有完整的生命周期，并且在manifest中注册过。相当于是本地的一个代理，他会调用插件中的方法来补足空壳activity中的一些动作。这样既做到了插件的动态加载，同时又保证了就想使用正常的activity一样去使用插件中的函数。</p>
<p>原理是这样。网上这样的例子也挺多的。</p>
<h4 id="u83B7_u53D6Resources_u5BF9_u8C61"><a href="#u83B7_u53D6Resources_u5BF9_u8C61" class="headerlink" title="获取Resources对象"></a>获取Resources对象</h4><p>对于第二个问题。一般我们使用Resouces,都是通过上下文也就是context.getResource得到resouce对象来对资源进行使用的。这里插件是被动态加载进来的，自然开始是没有上下文的。比如换肤操作，其中主要就是对一些图片等资源的利用。那么怎么才能得到Resouces对象呢，这篇博文<a href="http://blog.csdn.net/u010687392/article/details/47121729" target="_blank" rel="external"> 插件化开发—动态加载技术加载已安装和未安装的apk-Sunzxyong</a>就是对这样一个换肤例子的阐述。</p>
<ol>
<li><p>从已安装的apk中去获得皮肤资源</p>
<p> 这个我记得微博客户端好像就是皮肤是一个单独的apk进行安装，不知道是不是传统的这种从已安装的apk中去动态获取资源的方式进行换肤的。这种情况下，是可以根据包名来获取context的:</p>
<pre><code>Context plugnContext = this.createPackageContext(packageName, CONTEXT_IGNORE_SECURITY | CONTEXT_INCLUDE_CODE); 
</code></pre><p> 从已安装的apk中动态加载类，可以直接使用pathClassLoader</p>
</li>
<li><p>从external Storage中的jar文件来获取资源</p>
<p> 这个jar文件里面其实就是dex.class，上面举例就一直是这种情况。此时就不可以通过包名来创建context了，不过虽说创建不了context，我们要获取资源其实使用的是Resource对象，其实是可以不适用context就得到这个对象的：</p>
 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">protected <span class="keyword">void</span> loadResources(<span class="built_in">String</span> dexPath) &#123;    </span><br><span class="line">       <span class="keyword">try</span> &#123;    </span><br><span class="line">           AssetManager assetManager = AssetManager.<span class="keyword">class</span>.newInstance();    </span><br><span class="line">           Method addAssetPath = assetManager.getClass().getMethod(<span class="string">"addAssetPath"</span>, <span class="built_in">String</span>.<span class="keyword">class</span>);    </span><br><span class="line">           addAssetPath.invoke(assetManager, dexPath);    </span><br><span class="line">           mAssetManager = assetManager;    </span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;    </span><br><span class="line">           e.printStackTrace();    </span><br><span class="line">       &#125;    </span><br><span class="line">       Resources superRes = <span class="keyword">super</span>.getResources();    </span><br><span class="line">       superRes.getDisplayMetrics();    </span><br><span class="line">       superRes.getConfiguration();    </span><br><span class="line">       mResources = <span class="keyword">new</span> Resources(mAssetManager, superRes.getDisplayMetrics(),superRes.getConfiguration());    </span><br><span class="line">       mTheme = mResources.newTheme();    </span><br><span class="line">       mTheme.setTo(<span class="keyword">super</span>.getTheme());  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>可以看到使用了反射的机制去往管理资源的对象中加上插件资源的路径，这个mResource对象就是可以用来得到插件资源的Resouce对象了，这整个机制在<a href="http://blog.csdn.net/jiangwei0910410003/article/details/47679843" target="_blank" rel="external">Android中插件开发篇之—-应用换肤原理解析-尼古拉斯_赵四</a>有详细的解说。我的这个项目并没有用到资源的加载，不过这是插件化中一个非常重要的课题。</p>
<h3 id="u5173_u4E8Einterface_u5B9E_u73B0_u88AB_u52A0_u8F7D_u5BF9_u8C61_u7684_u65B9_u6CD5_u8C03_u7528"><a href="#u5173_u4E8Einterface_u5B9E_u73B0_u88AB_u52A0_u8F7D_u5BF9_u8C61_u7684_u65B9_u6CD5_u8C03_u7528" class="headerlink" title="关于interface实现被加载对象的方法调用"></a>关于interface实现被加载对象的方法调用</h3><p>使用interface转型方法的时候有个疑问，上面LibraryInterface是被加载的类com.example.dex.lib.LibraryProvider实现的接口。疑问在于，插件的类由于要implement接口,自然和接口有关，但同时在主程序里我们要用到这个interface的转型，也需要定义这个interface，所以插件和主程序都有这个Interface？</p>
<p>根据<a href="https://testerhome.com/topics/5026" target="_blank" rel="external">这一篇</a></p>
<p>方法是:</p>
<ul>
<li><p>把com.example.dex.lib.LibraryProvider打包成jar以后用dx工具转换成plugin.jar</p>
</li>
<li><p>把com.example.dex.interface.LibraryInterface打包成jar然后直接这个jar放到主工程的lib下:</p>
</li>
</ul>
<p><img src="/images/14691068206589.png" alt=""></p>
<ul>
<li>plugin.jar则是放在SD卡上，把这个路径传给dexClassLoader单做参数，用这个Loader来加载LibraryProvider生成instance并直接强制转换为LibraryInterface就可以了</li>
</ul>
<p>虽然插件的类也需要implement interface，但如果也加到插件中一起打包的话会和主程序中的interface冲突，然而一开始看到<a href="http://www.cnblogs.com/over140/archive/2011/11/23/2259367.html" target="_blank" rel="external">网上</a>有很奇怪的把interface也打包进被加载dex的。然而这篇里他自己后来也指出错误了。</p>
<p><a href="http://blog.csdn.net/bboyfeiyu/article/details/11710497" target="_blank" rel="external">这里</a>也是一个奇怪的把interface打包进去的。</p>
<blockquote>
<ul>
<li>@Description: 项目工程中必须定义接口， 而被引入的第三方jar包实现这些接口，然后进行动态加载 。 </li>
<li>相当于第三方按照接口协议来开发， 使得第三方应用可以以插件的形式动态加载到应用平台中</li>
</ul>
</blockquote>
<p>而且他在下一例让被加载类实现接口，一起打包，但是在主工程里面没用到interface的强制转换方法，而是用的反射的方法调用函数。</p>
<p><a href="https://segmentfault.com/a/1190000004062952" target="_blank" rel="external">这篇文章</a>讲的很好，但是在这个问题上没有指明，下面有人指出了这一点:</p>
<blockquote>
<p>有一个疑问，使用接口的方式。<br>如果将 IF 和 Impl 都打包进了 dex 文件，那么主项目里同时存在 IF，<br>两个 IF 在加载的时候会不会有问题呢。<br>我在尝试接口的方式的时候，抛出了这个异常<br>java.lang.IllegalAccessError: Class ref in pre-verified class resolved to unexpected implementation<br>还是说我自己理解有误？<br>尝试了一下，不能把 IF 文件也打包进去，IF 文件不冲突的时候，则不报错。</p>
</blockquote>
<p><a href="https://segmentfault.com/a/1190000004086213" target="_blank" rel="external">这个系列</a>讲的都挺好的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>项目已经过去很久了，虽然现在研究方向改变了很多，但是从毕设开始做这个到发现这个和目前流行的一些插件化原理很相似，这里再基于之前做的和之后学到的内容对动态加载做一个总结。</p>]]>
    
    </summary>
    
      <category term="akka" scheme="http://potatoker.github.io/tags/akka/"/>
    
      <category term="android" scheme="http://potatoker.github.io/tags/android/"/>
    
      <category term="build" scheme="http://potatoker.github.io/tags/build/"/>
    
      <category term="parallel" scheme="http://potatoker.github.io/tags/parallel/"/>
    
      <category term="android" scheme="http://potatoker.github.io/categories/android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[回溯法]]></title>
    <link href="http://potatoker.github.io/2016/08/17/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    <id>http://potatoker.github.io/2016/08/17/回溯法/</id>
    <published>2016-08-17T04:21:30.000Z</published>
    <updated>2016-08-17T04:35:05.038Z</updated>
    <content type="html"><![CDATA[<h2 id="1-_u516B_u7687_u540E_u95EE_u9898"><a href="#1-_u516B_u7687_u540E_u95EE_u9898" class="headerlink" title="1.八皇后问题"></a>1.八皇后问题</h2><p>最常见的回溯法处理的问题之一</p>
<p>首先，要理清最初始的框架就是，根据他的问题定义, 我们可以是一行一行来摆这个皇后保证不冲突同时思路清晰。</p>
<a id="more"></a> 
<p>那么我们的问题就成了，在摆第i行的时候我应该把皇后放到0:8的哪个列呢？<br>摆之前我们对照已经摆过的部分来检查一下到底可不可以摆到这一列。</p>
<p>可以说上面这个思路即使是一个没有学过编程的人拿到这个问题也应该想到的。我们的编程思路完全就是把上面这段话翻译了一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> GRID_SIZE = <span class="number">8</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">placeQueens</span><span class="params">(<span class="keyword">int</span> row, Integer[] columns, ArrayList&lt;Integer[]&gt; results)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(row == GRID_SIZE)&#123;</span><br><span class="line">        results.add(columns.clone())</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>; i &lt; GRID_SIZE; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(checkValid(columns, row, col))&#123;</span><br><span class="line">                columns[row] = col;</span><br><span class="line">                placeQueens(row+<span class="number">1</span>, columns, results);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里其实有些地方是需要稍作思考的，不过在这之前还是先看看checkValid</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkValid</span><span class="params">(Integer[] columns, <span class="keyword">int</span> row2, <span class="keyword">int</span> column2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> row1 = <span class="number">0</span>; row1 &lt; row2; i++)&#123;</span><br><span class="line">        column1 = columns[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//检查是否之前摆过相同的列</span></span><br><span class="line">        <span class="keyword">if</span>(column1 == column2)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//检查左上角和右上角是否有对角线上的碰撞，可以翻译成这么一条简洁的语句。</span></span><br><span class="line">        <span class="keyword">if</span>(row2-row1 == Math.abs(column2-column1))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不理清怎么check啊，会觉得有好多情况。<br>不可以同行，不可以同列，不可以对角线，对角线还分好多种。</p>
<p>还记得本来的思路框架吗，本来不就是说一行一行的摆的吗，我们在第一个函数里面就已经保证了绝对不可能同行。另外我们是从行数从小往大摆的，对角线出现的碰撞也只可能是左上角和右上角的碰撞。</p>
<p>当然，其实对角线这个可以做数学变形，不论是哪个方向的对角线碰撞都可以简化为:</p>
<pre><code>row2-row1 == Math.abs(column2-column1)
</code></pre><p>哦，对了，还有虽然很简单，但是很重要的啊，checkValid的思路是针对你下一个要摆的那个位置的。</p>
<p><code>checkValid(Integer[] columns, int row2, int column2)</code>就是你准备把下一个皇后摆在row2,column2，你现在要在columns里面已经摆过的(row &lt; row2)的位置里面去看看有没有那里摆过皇后会和我现在准备摆的这个(row2,column2)皇后发生碰撞。</p>
<p>前面摆过的一定遵守这个规则，要对当前要摆的皇后进行check</p>
<p>最后一个问题。</p>
<p>看下面这个<a href="https://leetcode.com/problems/n-queens/" target="_blank" rel="external">leetcode</a>题的一个解:</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;<span class="keyword">String</span>&gt;&gt; solveNQueens(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        List&lt;List&lt;<span class="keyword">String</span>&gt;&gt; res = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        ArrayList&lt;<span class="keyword">String</span>&gt; cur = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++) sb.<span class="built_in">append</span>(<span class="string">'.'</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++) cur.<span class="built_in">add</span>(sb.toString());</span><br><span class="line">        helper(n, <span class="number">0</span>, cur, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> helper(<span class="built_in">int</span> n, <span class="built_in">int</span> row, ArrayList&lt;<span class="keyword">String</span>&gt; cur, List&lt;List&lt;<span class="keyword">String</span>&gt;&gt; res) &#123;</span><br><span class="line">        <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">            List&lt;<span class="keyword">String</span>&gt; toAdd = <span class="keyword">new</span> ArrayList();</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; cur.<span class="built_in">size</span>(); i++) toAdd.<span class="built_in">add</span>(cur.<span class="built_in">get</span>(i));</span><br><span class="line">            res.<span class="built_in">add</span>(toAdd);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isValid(n, cur, row, j)) &#123;</span><br><span class="line">                StringBuilder sb = <span class="keyword">new</span> StringBuilder(cur.<span class="built_in">get</span>(row));</span><br><span class="line">                sb.setCharAt(j, <span class="string">'Q'</span>);</span><br><span class="line">                cur.<span class="built_in">set</span>(row, sb.toString());</span><br><span class="line">                helper(n, row+<span class="number">1</span>, cur, res);</span><br><span class="line">                sb.setCharAt(j, <span class="string">'.'</span>);</span><br><span class="line">                <span class="comment">// cur.set(row, sb.toString());</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">boolean</span> isValid(<span class="built_in">int</span> n, ArrayList&lt;<span class="keyword">String</span>&gt; cur, <span class="built_in">int</span> row, <span class="built_in">int</span> col) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.<span class="built_in">get</span>(i).charAt(j) == <span class="string">'Q'</span> &amp;&amp; (j == col || Math.<span class="built_in">abs</span>(row-i) == Math.<span class="built_in">abs</span>(col-j))) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>helper方法里面我有一行注释的语句。</p>
<p>我递归的时候是把皇后摆在了当前row,j这个位置，现在递归返回，我回溯了。回到row-1这个地方然后尝试摆到j+1,</p>
<p>上面这个就是所谓深度优先遍历，然后回溯的思想。</p>
<p>所以注意到有一个想法是很直观的，上面这个用的是一个cur变量来保存棋盘上皇后的位置。我现在是从row回溯到row-1，递归返回，表明回到row-1，重新把row-1这一行的皇后换个列摆放。</p>
<p>but</p>
<p>在回溯之前我们就摆过row-1了，row-1这一行的某一列已经被置Q了(这里是置Q)，现在我们重新摆，所以要把之前摆的这个Q给他抹掉才行。</p>
<p>but</p>
<p>好像一开始上面写的那个没有这个”抹掉”的过程呢?</p>
<p>发现其实有些人也似乎是没有关系这个步骤比如这个<a href="http://kekecv.com/2016/08/02/N-Queens%20%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/" target="_blank" rel="external">链接</a>他的解法是不需要抹掉，但是仍然写上去了，虽然不影响对错。</p>
<p>其实这个跟存储皇后位置所使用的数据结构有关。你可以发现你</p>
<ul>
<li><p>第一个代码使用的是columns[i]==j表示第i行的皇后放在第j列这个含义。</p>
</li>
<li><p>第二个代码cur.get(i).charAt(j)==’Q’同样表示第i行的皇后放在j列。</p>
</li>
</ul>
<p>如果是一维的，你可以发现每次你重新放row-1行的皇后到下一列这个操作是一个“复写”操作！它本身就会抹掉之前。</p>
<p>因为实际上当你返回到row-1行去然后j+1，然后调用checkValid，这个时候其实row-1,j+1那个地方是有值的。</p>
<p>不过这不影响什么，也许只是如果可视化之后这个地方会稍显得不那么符合逻辑，但是根本没有影响，因为我们又不和同一行的比较。</p>
<hr>
<p>然而，如果是二维的,那就很不一样了，如果你没有”抹掉”这个操作，那么你在回溯到row-1，重新设置j+1的时候，发现如果检查对了(其实仍然不会影响检查)，但是！你重新设置row-1,j+1的时候，之前的痕迹还留在cur状态数组里面！而如果使用columns[i]=j这样的话，会抹掉之前的值。所以他不需要人为的抹掉。</p>
<hr>
<p>所以，八皇后问题，其实要根据一些题目的额外条件来判断使用一维数组来保存状态还是用二位数组来保存状态会比较方便一点。</p>
<p>如果使用二维数组，那么一定要有”回溯后的抹掉”操作.</p>
<h2 id="2-__u65B9_u6CD5_u8BBA"><a href="#2-__u65B9_u6CD5_u8BBA" class="headerlink" title="2. 方法论"></a>2. 方法论</h2><p>很多问题可以理解为回溯问题，同样也有别的思路，如果没有整理回溯法的方法论，看到可能会是一些<a href="http://wuchong.me/blog/2014/07/28/permutation-and-combination-realize/" target="_blank" rel="external">聪明解法</a>。</p>
<p>但如果能判定一个问题可以使用回溯来解决，基本上答案也就出来了</p>
<p>这里有个<a href="https://discuss.leetcode.com/topic/46162/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partioning" target="_blank" rel="external">leetcode</a>帖子整理了许多经典的回溯法。觉得很有用。</p>
<h2 id="3-__u518D_u770B_u5168_u6392_u5217"><a href="#3-__u518D_u770B_u5168_u6392_u5217" class="headerlink" title="3. 再看全排列"></a>3. 再看全排列</h2><p>应该能感觉到全排列应该是最典型的回溯法应用之一了。</p>
<p>之前全排列我理解的方法是递归的思想，abc，得到bc这个自问题的全排列，然后把a加进去。大概是这么个思路，是比较典型的递归思想，假设一个子问题已经得到了解决并得到了结果。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class <span class="type">Solution</span>(<span class="keyword">object</span>):</span><br><span class="line">    def permute(self, nums):</span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">        """</span></span><br><span class="line">        <span class="literal">result</span> = []</span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="literal">result</span>.append(nums)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">result</span></span><br><span class="line">        </span><br><span class="line">        sub_permute = self.permute(nums[<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">for</span> list <span class="keyword">in</span> sub_permute:</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="type">range</span>(<span class="number">0</span>,len(list)+<span class="number">1</span>):</span><br><span class="line">                </span><br><span class="line">                new_list = list[<span class="number">0</span>:i]+[nums[<span class="number">0</span>]]+list[i:]</span><br><span class="line">                </span><br><span class="line">                <span class="literal">result</span>.append(new_list)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">result</span></span><br></pre></td></tr></table></figure>
<p>主要这个语句</p>
<pre><code>new_list = list[0:i]+[nums[0]]+list[i:]
</code></pre><p>就是在得到子串的全排列的情况下，把第一个元素再”安进去”</p>
<p>==其实虽然回溯法用到了递归，可是觉得回溯的思想框架和传统递归还是有差别的，递归是在当前层用子问题的结果解决问题，然而回溯的思想是要想到好多层以后，这里就是决策树！==</p>
<p>其实想想我们最原始的写一个字符串的全排列是怎么做的</p>
<pre><code>abc
</code></pre><ol>
<li>第一个位置，可以放a或b或c,这里先放a（bc暂且记下）</li>
<li>第一个位置放了a,第二个位置可以放b或c，这里先放b(c暂且记下)</li>
<li>第二个位置放了b,第三个位置只能发c了。</li>
<li>回到第2，第二个位置放c,这样第三个位置只能放b</li>
<li>回到第1，第一个位置放b…..</li>
</ol>
<p>其实这个思考过程就是一个决策树的形成过程:<br><img src="/images/bc.pic.jpg" alt="bc.pi"></p>
<p>顺带的八皇后其实也是一个决策树，</p>
<p><img src="/images/Screen%20Shot%202016-08-11%20at%204.22.33%20PM.png" alt="Screen Shot 2016-08-11 at 4.22.33 P"></p>
<p>好吧这里是我自己瞎写的一个回溯法的框架:</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> backTracking(<span class="type">List</span> path, <span class="type">int</span> level)&#123;</span><br><span class="line">    //到达叶子</span><br><span class="line">    <span class="keyword">if</span>(level == somesize)</span><br><span class="line">        <span class="keyword">do</span> some thing to show the <span class="literal">result</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> every possible selection i <span class="keyword">for</span> next level:</span><br><span class="line">            <span class="keyword">if</span>(checkValid(level,i))</span><br><span class="line">                path.add(i)</span><br><span class="line">                backTracking(path, level+<span class="number">1</span>)</span><br><span class="line">                path.remove(i)</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>每次进入backTracking先看需不需要对当前这个Path进行操作</li>
<li>枚举所有下一层可能的选择并把结果放入当前的path list,</li>
<li>这个“可能”体现在有的时候要对一些情况进行过滤，比如，八皇后第i行的皇后要放在第几列呢?我们是可以根据path中，0~i列已经放了的位置来判断有些列是不可能作为第i行的放入位置的。之一看看上面那个columns数组，其实就是这里path的作用哦，记录当前层位置一斤走过的level的设置的所有值。</li>
<li>path数组是会不断变化的，没一次变化就是一次对当前index level的取值的调整。如果这个path的数据结构是list，那么一定要有显示的path.remove(i)的操作。方便递归栈弹出后再相同的层直接添加另一个选择。</li>
</ol>
<p>直接看用回溯法做全排列的例子:(字符串没有重复元素)</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">   <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; <span class="keyword">list</span> = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   <span class="comment">// Arrays.sort(nums); // not necessary</span></span><br><span class="line">   backtrack(<span class="keyword">list</span>, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> void backtrack(<span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; <span class="keyword">list</span>, <span class="keyword">List</span>&lt;Integer&gt; tempList, <span class="keyword">int</span> [] nums)&#123;</span><br><span class="line">   <span class="keyword">if</span>(tempList.size() == nums.length)&#123;</span><br><span class="line">      <span class="keyword">list</span>.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">   &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123; </span><br><span class="line">         <span class="keyword">if</span>(tempList.contains(nums[i])) <span class="keyword">continue</span>; <span class="comment">// element already exists, skip</span></span><br><span class="line">         tempList.add(nums[i]);</span><br><span class="line">         backtrack(<span class="keyword">list</span>, tempList, nums);</span><br><span class="line">         tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到:</p>
<ol>
<li>tempList其实就是path的作用，nums里面自然是可选的数字了，当<code>tempList.size() == nums.length</code>当然说明走到了决策树的叶子结点，比如123全排列，自然当path里面都有3个值了，这个完整的path也就形成了。</li>
<li>这里走到决策树的叶子结点的操作就是加到我们的结果列表里面，nothing special</li>
<li>枚举里面其实也有对可能的下一层的取值的判断哦，就是<code>if(tempList.contains(nums[i])) continue;</code>如果和前面path中已有的元素重复，作为全排列肯定是在这一level是不可选的。</li>
</ol>
<p>所以可以看见这个也是刚好可以契合我们前面那个回溯法的模板的。是比较典型的全排列。我相信应该比上面那个普通递归的做法思路更简单些。</p>
<h2 id="4-__u5B50_u96C6"><a href="#4-__u5B50_u96C6" class="headerlink" title="4. 子集"></a>4. 子集</h2><p>看<a href="https://leetcode.com/problems/subsets/" target="_blank" rel="external">leetcode</a>这一题，给出不重复的list[1,2,3]给出这个集合的所有字节</p>
<p>这个看起来其实也是要给出一些组合序列嘛，和我们前面的全排列问题挺像的。</p>
<p>不过马上会遇到困难，这里怎么感觉写不出到达决策树叶子的条件</p>
<pre><code>if(level == somesize)
        do some thing to show the result
</code></pre><p>这个判断走到了决策树的叶子结点的语句</p>
<p>没错，因为这里执行的”打印操作”或者说得到一个完整的”path”的时候并不一定出现在决策树的叶子结点。这里我们的决策树构造就要提前做一些”哪些是可选的选择”的工作。这里可以看到在走向叶子结点的过程中经历的所有路径都是valid的路径结果</p>
<p>所以:</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; <span class="keyword">list</span> = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    backtrack(<span class="keyword">list</span>, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> void backtrack(<span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; <span class="keyword">list</span> , <span class="keyword">List</span>&lt;Integer&gt; tempList, <span class="keyword">int</span> [] nums, <span class="keyword">int</span> start)&#123;</span><br><span class="line">    <span class="keyword">list</span>.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i++)&#123;</span><br><span class="line">        tempList.add(nums[i]);</span><br><span class="line">        backtrack(<span class="keyword">list</span>, tempList, nums, i + <span class="number">1</span>);</span><br><span class="line">        tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>list是一个List的List，用来保存所有可能的path(path是一个list)</li>
<li>tempList相当于我们的path</li>
<li>这里的start其实蕴含了我们前面模板的<code>if(checkValid(level,i))</code>,比如在level0 选择了nums[1],之后，level[1]的选择只能是nums[2]及其之后元素。</li>
</ol>
<p>感觉子集这一题是稍微特殊一点的。如果一开始就能理清不重复子集的产生思路，就能画出那个决策树帮你直接给出所有答案，然后写出回溯就是很简单的事情了。</p>
<p>既然这个有点难懂，那么再检验一下有没有真的搞懂子集，如果给出的全集有重复元素怎么办呢?<a href="https://leetcode.com/problems/subsets-ii/" target="_blank" rel="external">leetcode</a></p>
<p>现要产生[1,2,2,3]的所有子集，还是画一下决策树:</p>
<p><img src="/images/5.pic.jpg" alt="5.pi"></p>
<p>注意看画x的要排除的选择的部分</p>
<p>老实说我想了很久没有想到,觉得这个规律并不是很直观。。。</p>
<p>x的特点是什么:</p>
<p><code>if(i &gt; start &amp;&amp; nums[i] == nums[i-1]) continue;</code></p>
<p>那么对比之前的其实也就加了这么一个checkvalid 选择的过滤:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    backtrack(list, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, <span class="keyword">int</span> [] nums, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">    list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; start &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// skip duplicates</span></span><br><span class="line">        tempList.add(nums[i]);</span><br><span class="line">        backtrack(list, tempList, nums, i + <span class="number">1</span>);</span><br><span class="line">        tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-__u6811_u7684_u56DE_u6EAF"><a href="#5-__u6811_u7684_u56DE_u6EAF" class="headerlink" title="5. 树的回溯"></a>5. 树的回溯</h2><p>树的回溯简直就是本身就是决策树。。不过这里思考的时候，想的是，我现在要枚举下一level的可能的情况。枚举的有要么左子树，要么右子树。</p>
<p>这个是之前做过的，copy过来:</p>
<h3 id="5-1__u7ED9_u5B9A_u4E00_u68F5_u4E8C_u53C9_u6811_uFF0C_u5176_u4E2D_u6BCF_u4E2A_u8282_u70B9_u90FD_u542B_u6709_u4E00_u4E2A_u6570_u503C_uFF0C_u8BBE_u8BA1_u4E00_u4E2A_u7B97_u6CD5_uFF0C_u6253_u5370_u7ED3_u70B9_u6570_u503C_u603B_u548C_u7B49_u4E8E_u67D0_u4E2A_u7ED9_u5B9A_u503C_u7684_u6240_u6709_u8DEF_u5F84_uFF0C_u6CE8_u610F_u8DEF_u5F84_u4E0D_u4E00_u5B9A_u975E_u5F97_u4ECE_u4E8C_u53C9_u6811_u7684_u6839_u7ED3_u70B9_u6216_u53F6_u7ED3_u70B9_u5F00_u59CB_u6216_u7ED3_u675F_u3002"><a href="#5-1__u7ED9_u5B9A_u4E00_u68F5_u4E8C_u53C9_u6811_uFF0C_u5176_u4E2D_u6BCF_u4E2A_u8282_u70B9_u90FD_u542B_u6709_u4E00_u4E2A_u6570_u503C_uFF0C_u8BBE_u8BA1_u4E00_u4E2A_u7B97_u6CD5_uFF0C_u6253_u5370_u7ED3_u70B9_u6570_u503C_u603B_u548C_u7B49_u4E8E_u67D0_u4E2A_u7ED9_u5B9A_u503C_u7684_u6240_u6709_u8DEF_u5F84_uFF0C_u6CE8_u610F_u8DEF_u5F84_u4E0D_u4E00_u5B9A_u975E_u5F97_u4ECE_u4E8C_u53C9_u6811_u7684_u6839_u7ED3_u70B9_u6216_u53F6_u7ED3_u70B9_u5F00_u59CB_u6216_u7ED3_u675F_u3002" class="headerlink" title="5.1  给定一棵二叉树，其中每个节点都含有一个数值，设计一个算法，打印结点数值总和等于某个给定值的所有路径，注意路径不一定非得从二叉树的根结点或叶结点开始或结束。"></a>5.1  给定一棵二叉树，其中每个节点都含有一个数值，设计一个算法，打印结点数值总和等于某个给定值的所有路径，注意路径不一定非得从二叉树的根结点或叶结点开始或结束。</h3><p>看到这个“路径”这个词，你就应该明白这个很可能是用回溯法处理的。不过这里要弄清楚到底题中的路径一词指的是什么。</p>
<p>也看到题中强调了:</p>
<pre><code>路径不一定非得从根开始，在叶子结束。
</code></pre><p>不在叶子结束，这个怎么有点像前面子集的问题。没错当不在叶子结点结束的时候，我们没有必要做如</p>
<pre><code>八皇后的row==size的判断
或者全排列的templist == nums.length这种判断
</code></pre><p>才算是有一个可用的path。</p>
<p>可是这里又看到，不一定是在根节点开始？。。。这个之前可没遇到过。<br>不过稍微变通一下就知道，如果我们正常写这个回溯，那么path里存的是根到当前结点路过的结点值。现在不一定要从根开始，而我们的path又是在增长的。那么我们从当前走到的层倒着把path里的值都加起来不就可以做出所有不定头不定尾的判断吗</p>
<p>至于枚举的话，直接枚举左孩子和右孩子就可以了</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> findSum(TreeNode root, <span class="keyword">int</span>[] path, <span class="keyword">int</span> <span class="keyword">sum</span>, <span class="keyword">int</span> level)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    path[level] = root.data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = level; i &gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        temp += path[i];</span><br><span class="line">        <span class="keyword">if</span>(temp == <span class="keyword">sum</span>)</span><br><span class="line">            print(path, i, level);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    findSum(root.left, path, <span class="keyword">sum</span>, level+<span class="number">1</span>);</span><br><span class="line">    findSum(root.right, path, <span class="keyword">sum</span>, level+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//这里是回溯的体现，虽然在这一题里其实属于之前的八皇后提到的覆盖，但是这里书上也是着重强调了虽然可以没有这一句，但是记住要有这么一个逻辑操作是一个好习惯，毕竟有的时候确实需要这么一个"抹掉"操作。</span></span><br><span class="line">    path[level]  = Integer.MIN_VALUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-2__u8DEF_u5F84_u9650_u5B9A_u5728_u5FC5_u987B_u4ECE_u6839_u5F00_u59CB_uFF0C_u5728_u53F6_u5B50_u7ED3_u675F"><a href="#5-2__u8DEF_u5F84_u9650_u5B9A_u5728_u5FC5_u987B_u4ECE_u6839_u5F00_u59CB_uFF0C_u5728_u53F6_u5B50_u7ED3_u675F" class="headerlink" title="5.2 路径限定在必须从根开始，在叶子结束"></a>5.2 路径限定在必须从根开始，在叶子结束</h2><p>如果是这样的话:</p>
<ol>
<li>我们要有走到决策树的叶子节点的常规判断了</li>
<li>没必要倒着判断了</li>
<li>由于终点停在叶子结点(其实前面说的叶子结点是遇到的第一个null)，那么这里就要有可能选择判断了，这个选择判断也就是有没有子树而已</li>
</ol>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> void backTrackingTreeSum(TreeNode root, <span class="keyword">int</span> sum, <span class="keyword">int</span> current_sum, ArrayList&lt;TreeNode&gt; <span class="keyword">list</span>)&#123;</span><br><span class="line">     <span class="keyword">list</span>.add(root);</span><br><span class="line">     <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; sum == current_sum)&#123;</span><br><span class="line">         System.out.println(<span class="string">"a path found:"</span>);</span><br><span class="line">         <span class="keyword">for</span>(TreeNode node : <span class="keyword">list</span>)</span><br><span class="line">             System.out.<span class="keyword">print</span>(node.val);</span><br><span class="line">         System.out.<span class="keyword">print</span>(<span class="string">"\n"</span>);</span><br><span class="line">     &#125;</span><br><span class="line"><span class="comment">//其实这个也可以看做八皇后的valid判断了</span></span><br><span class="line">  <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)</span><br><span class="line">      backTrackingTreeSum(root.left, sum, current_sum+root.val, <span class="keyword">list</span>);</span><br><span class="line">  <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)</span><br><span class="line">      backTrackingTreeSum(root.right, sum, current_sum+root.val, <span class="keyword">list</span>);</span><br><span class="line">  <span class="keyword">list</span>.remove(<span class="keyword">list</span>.size()-<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="1-_u516B_u7687_u540E_u95EE_u9898"><a href="#1-_u516B_u7687_u540E_u95EE_u9898" class="headerlink" title="1.八皇后问题"></a>1.八皇后问题</h2><p>最常见的回溯法处理的问题之一</p>
<p>首先，要理清最初始的框架就是，根据他的问题定义, 我们可以是一行一行来摆这个皇后保证不冲突同时思路清晰。</p>]]>
    
    </summary>
    
      <category term="java，basic" scheme="http://potatoker.github.io/tags/java%EF%BC%8Cbasic/"/>
    
      <category term="general" scheme="http://potatoker.github.io/categories/general/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[浅析Binder机制]]></title>
    <link href="http://potatoker.github.io/2016/08/17/Binder/"/>
    <id>http://potatoker.github.io/2016/08/17/Binder/</id>
    <published>2016-08-17T03:51:30.000Z</published>
    <updated>2016-08-17T04:10:39.355Z</updated>
    <content type="html"><![CDATA[<p>并没有找到讲binder机制特别清晰的中文资料</p>
<p>终于在youtube上找到一个<a href="https://www.youtube.com/watch?v=Jgampt1DOak" target="_blank" rel="external">演讲</a>和<a href="http://events.linuxfoundation.org/images/stories/slides/abs2013_gargentas.pdf" target="_blank" rel="external">slides</a>,以及<a href="https://www.nds.rub.de/media/attachments/files/2012/03/binder.pdf" target="_blank" rel="external">这篇</a>资料作为补充，从更全面的角度介绍了更细致的前因后果的</p>
<a id="more"></a>
<p><img src="/images/Screen%20Shot%202016-07-24%20at%2010.20.14%20AM.png" alt=""></p>
<p>首先看这张把最主要的几个部分显示出来的图，可以看到process A和B的通信稍显曲折，这也是看到其他博客整片”A调用B,B又调用C”的原因。</p>
<p>这里还有一个类之间的调用关系抽象图，同样截取自上面的youtube presentation的slides。</p>
<p><img src="/images/Screen%20Shot%202016-07-24%20at%2010.18.48%20AM.png" alt="Screen Shot 2016-07-24 at 10.18.48 A"></p>
<p>这里首先有个基本的概念。进程间的通信，比如你在进程A 里面用service.invoke(func)，所谓IPC是真正的执行主体是在进程B，这里</p>
<h2 id="u8FD9_u91CC_u5148_u8BF4_u4E00_u4E2A_u95EE_u9898_uFF0C_u4E3A_u4EC0_u4E48_u8981_u7528cs_u7ED3_u6784_uFF1F_u4E3A_u4EC0_u4E48_u8981_u7528IPC_u901A_u4FE1_3F"><a href="#u8FD9_u91CC_u5148_u8BF4_u4E00_u4E2A_u95EE_u9898_uFF0C_u4E3A_u4EC0_u4E48_u8981_u7528cs_u7ED3_u6784_uFF1F_u4E3A_u4EC0_u4E48_u8981_u7528IPC_u901A_u4FE1_3F" class="headerlink" title="这里先说一个问题，为什么要用cs结构？为什么要用IPC通信?"></a>这里先说一个问题，为什么要用cs结构？为什么要用IPC通信?</h2><p>其实在一个系统中client和server的概念还是挺明确的，用户程序常常要使用一些通用的系统服务，gps,alarm等等，这些肯定是安卓系统负责去维护的。包括开一个activity，task栈是可以跨进程的，维护这个栈肯定也是系统去维护。</p>
<p>既然这么多需要系统去同意维护的服务，那么就采用c/s结构，上面的各个client都可以向系统请求这些服务，系统也方便管理。</p>
<p>显然，系统服务和用户进程是两个进程，他们之间的通信是IPC。</p>
<h2 id="u4E00_u76F4_u5728_u8BF4_u7684binder_u5230_u5E95_u662F_u4E2A_u4EC0_u4E48_u4E1C_u897F"><a href="#u4E00_u76F4_u5728_u8BF4_u7684binder_u5230_u5E95_u662F_u4E2A_u4EC0_u4E48_u4E1C_u897F" class="headerlink" title="一直在说的binder到底是个什么东西"></a>一直在说的binder到底是个什么东西</h2><p>一般Binder，就是指binder机制，在一些描述中，有的会说把这个binder传给谁。不过在上面两篇里面基本很少这么使用。</p>
<p>先看资料给出的定义:</p>
<ul>
<li>IBinder InterfaceA well-defined behavior (i.e. methods) that Binder Objects must implement</li>
</ul>
<ul>
<li><p>Binder (Object)A generic implementation of the IBinder interface</p>
</li>
<li><p>Binder TokenAn abstract 32-bit integer value that uniquely identifies a Binder object across all processes on the system</p>
</li>
</ul>
<p>主要是binder(object)的解释，就是只要实现了ibinder的就是binder，这个ibider类根据下面的知道就是android.os.Binder<br>再看看上面的图，整个binder框架中会用到的类，就是那么几个，那么这个和android.os.Binder有关的类是哪个？</p>
<p>当然详细的关于这几个类的分析在后面，但是现在就可以给出答案,可以看了后面再跳回来看:</p>
<p>这是一个使用AIDL帮我们生成的类的类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> others;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by raymond on 7/24/16.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">package</span> com.example.app;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IFooService</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">IInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">example</span>.<span class="title">app</span>.<span class="title">IFooService</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> com.example.app.<span class="function">IFooService <span class="title">asInterface</span><span class="params">(</span><br><span class="line">                android.os.IBinder obj)</span> </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> com.example.app.IFooService.Stub.Proxy(obj);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span></span><br><span class="line">                flags)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123; <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">case</span> TRANSACTION_save: &#123;</span><br><span class="line">                ...</span><br><span class="line">                com.example.app.Bar _arg0;</span><br><span class="line">                ...</span><br><span class="line">                _arg0 = com.example.app.Bar.CREATOR.createFromParcel(data);</span><br><span class="line">                <span class="keyword">this</span>.save(_arg0);</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            ... &#125;</span><br><span class="line">            ... &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">example</span>.<span class="title">app</span>.<span class="title">IFooService</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> android.os.IBinder mRemote;</span><br><span class="line">            ...</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(com.example.app.Bar bar)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">                ...</span><br><span class="line">                android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">                ...</span><br><span class="line">                bar.writeToParcel(_data, <span class="number">0</span>);</span><br><span class="line">                ...</span><br><span class="line">                mRemote.transact(Stub.TRANSACTION_save, _data, _reply, <span class="number">0</span>); ...</span><br><span class="line">            &#125; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没错，就是调用图里面的那个service.stub类，是一个抽象类，他<code>extends android.os.Binder</code>这个类算作是要和C++ middleware(上图调用层里面的libbinder)通信的类，是java层面service的最下面的类。他的主要方法是ontrasict()，向这个transic data里面设置一些值，这些值可能就是返回值，ontransict()就是在他收到C++ middleware的trasiction 的时候的回调函数，他通过执行本地方法，得到结果保存到trancsiction里面并且返回。当然其实后面的比如serviceimp或者service都直接或者间接的extends了stub这个类，不过因为stub类是和c++ middleware打交道的类，是Binder机制语境中提到更多的类。</p>
<p>另外注意proxy这个类是被client使用的，他手上有stub类的引用，也就是有Binder的引用，所以也可以看到</p>
<p><code>mRemote.transact(Stub.TRANSACTION_save, _data, _reply, 0)</code></p>
<p>他在向binder发送这个transact data.并且这一动作是发生在client端的。</p>
<h2 id="u77E5_u9053_u4E86binder_u662F_u4E2Astub_uFF0C_u90A3_u4E48_uFF0C_u5230_u5E95_u600E_u4E48_u5B9E_u73B0_u7684IPC_u7684_u554A"><a href="#u77E5_u9053_u4E86binder_u662F_u4E2Astub_uFF0C_u90A3_u4E48_uFF0C_u5230_u5E95_u600E_u4E48_u5B9E_u73B0_u7684IPC_u7684_u554A" class="headerlink" title="知道了binder是个stub，那么，到底怎么实现的IPC的啊"></a>知道了binder是个stub，那么，到底怎么实现的IPC的啊</h2><p>其实所谓IPC，就是你要实现一套通信机制，这边说话那边你要听得懂，听不懂就找个中间人来翻译。同时要保证一个人说一个人听不会乱套，保证两个人不能抢着说。</p>
<p>其实你看linux里面ipc</p>
<ol>
<li>socket方式，本来就是网络进程间通信方式，是在tcp之上的一套通信协议，肯定能额保证两边正常对话。</li>
<li>pipe，其实就是两个process 一个拿读指针一个拿写指针去操作同一个文件，这个文件就是他们交流的管道，</li>
</ol>
<p>binder呢?</p>
<p>它主要做了一件事情就是prcess A中<code>service_local.func(arg)</code>，这个调用实际上发生在service进程里面，类似<code>service_remote.func(arg)</code>。</p>
<p>这里binder IPC要做的就是我不可能直接告诉你service_remote这个对象在process B里的真实地址，事实上即使你真的知道这个地址(一串数字)，由于JVM的机制，你也不可能调用func，去执行这个命令。这是出于安全的考虑，process之间有天然的隔阂。</p>
<p>这个时候，就要一个中间人，甚至更多的中间人来帮助他们沟通</p>
<p>这里最明显要有一个中间人在知道把这个service_local.func(arg)告诉对应的process B，并且让他在真实的service对象上进行一些列的操作。</p>
<p>这个把调用信息告诉中间人的方法就是把这个函数调用抽象成一个特定的数据结构(我干脆理解成网络通信里面的通信包似的)</p>
<p>这个数据结构就叫Transmission data,也有叫trasiction：</p>
<p><img src="/images/Screen%20Shot%202016-07-24%20at%2010.38.53%20AM.png" alt="Screen Shot 2016-07-24 at 10.38.53 A"></p>
<p>这个其实就跟网络通信的包一样嘛，几个域规定了几个特定的信息。</p>
<p>这个transmission data就描述了这次调用。包括</p>
<ul>
<li>是哪个service去调用(target)，这个target真实的情况是一个binder token</li>
</ul>
<p>ok,ok,ok,看一眼上面的binder Token是什么。</p>
<blockquote>
<p>An abstract 32-bit integer value that uniquely identifies a Binder object across all processes on the system</p>
</blockquote>
<p>先明确一点，这个进行翻译的中间人就是binder driver,看看binder driver怎么“翻译”的:</p>
<blockquote>
<p>On every transaction, the binder driver automaticallymaps local addresses to remote binder handles and remote binder handles to local addresses</p>
</blockquote>
<p>我们确认一下，这个local address就是我们上面说的binder Token吗:</p>
<blockquote>
<p>A binder object reference is one of the following </p>
<ul>
<li>An actual virtual memory address to a binder object in the same process* An abstract 32-bit handle to a binder object inanother process</li>
</ul>
</blockquote>
<p><img src="/images/Screen%20Shot%202016-07-24%20at%2011.17.30%20AM.png" alt="Screen Shot 2016-07-24 at 11.17.30 A"></p>
<p>我们这里谈general的情况，所以都是指IPC，所以属于第二种情况。所以，没错！transaciton的target的值就是一个binder Token,binder driver的作用就是把这个binder Token翻译成指向process B的binder(stub对象)的引用!!</p>
<blockquote>
<p>On every transaction, the binder driver automaticallymaps local addresses to remote binder handles and remote binder handles to local addresses</p>
</blockquote>
<p>至此，谜团差不多解开了。</p>
<p>其实就是process A向调B的某个方法，他不能直接调用，他把调用信息打包成一个叫trsaction的数据结构，这个结构中主要包括:</p>
<ul>
<li>哪个service对象去执行(binder token来表示)</li>
<li>这个serivice的哪个方法</li>
<li>进行过数据变换的一些函数参数（这个过程叫parcel）</li>
</ul>
<blockquote>
<p>Parcel: Container for a message (data and object references) that can be sent through an IBinder</p>
</blockquote>
<p>然后这个trascation会通过Linux ioctl命令(c++ middleware层在做这件事)发送到binder driver这个内核空间的一块区域，在这里保存着binder token到process B binder对象（stub对象，即service对象)的引用的映射。由此就找到了真正的service对象他收到transaciton中的调用信息，进行执行，然后把返回值信息设置进一个reply parcel，然后再调用iotcl把改变过的transaction发送给client里的proxy。</p>
<p>这个过程看上面的调用图应该很明白了。<br>这里我才醒悟的一点是，在返回的时候我在想，process B返回一个parcel而不是trascation也就是不指定地址?这不也是进程间通信吗，为什么这个就可以直接返回数据?难道不是和之前一样给一个地址符（binder Token吗）</p>
<p>不不不，注意这里client把trasaction通过iotcl给binder driver的时候的描述：(结合第二张调用图)</p>
<p>client：</p>
<ul>
<li>4)submit transaction/data via a blocking ioctl call</li>
</ul>
<p>service:</p>
<ul>
<li>5)wake up from a blocking iotcl call and get the transaction data</li>
</ul>
<p>service设置transaction<br>service：</p>
<ul>
<li>13）submit replyParcel via ioctl</li>
<li>14）wake up from a blocking ioctl call and get transaction reply data</li>
</ul>
<p>再看一段关于procss B 执行完相应方法后的描述:</p>
<blockquote>
<p>Again it is routed through the layers to the binder driver, that transfers the parcel and wakes up the sleeping client process and delivers the reply parcel to the proxy object. </p>
</blockquote>
<p>也就是说client在等待这个方法的完成.调用的client一直在binder driver的iotcl这个命令中等待，所以binder driver只需要拿到了返回的parcel，他又通过iotcl把返回parcel穿给这个等待的client就可以了。</p>
<p>所以你注意到了目前讲的全部都是阻塞式的调用。当然也可以实现非阻塞式调用。</p>
<h3 id="binder_token__u54EA_u91CC_u6765_u7684"><a href="#binder_token__u54EA_u91CC_u6765_u7684" class="headerlink" title="binder token 哪里来的"></a>binder token 哪里来的</h3><p>前面讲了这么多，这个binder token到底是什么，反正就是只要client知道了binder Token并把它装进tracsaction里，binder driver收到后就可以通过映射关系找到真正的binder handler了。</p>
<p>那么到底client是怎么获得binder Token 的？</p>
<p>这里看context Manager的描述:</p>
<blockquote>
<p>Each Binder that needs to publish its name due to being a service, submits a name and its Binder token to the service manager. Relying on that feature, the client must only know the name of a service and asks the service manager for the Binder address of the requested service.</p>
</blockquote>
<p>这个context Manager有个更常用的名字service Manager</p>
<p>service Manger也是一个service，没错，他在单独的线程一直运行着。</p>
<p>他的作用就是把service name映射成binder token, 每个service都需要注册，这个你是懂的，在manifest里面。注册就是发生在这个service Manager里面。生成一条记录:servcice name -&gt;binder token.</p>
<p>所以当client 请求其他服务的时候第一件要做的事情就是向service manager做出请求，然后通过Binder机制，得到要请求的服务的binder token传给proxy，proxy会放到transaction里面。</p>
<p>这里的问题上是，如果必须要通过service manger才能得到binder token (相当于service binder的地址)，那servicemanger自己的地址我怎么知道呢?</p>
<p>这个已经规定好了，向servicemanager请求服务，binder token 无需查询，就是0！直接用。</p>
<h3 id="AIDL"><a href="#AIDL" class="headerlink" title="AIDL"></a>AIDL</h3><p>好了，Binder机制差不多了吧。这里还是看上图，关键的有两个类，一个是stub类，一个是proxy类，分别是和c++ middleware打交道的属于service process和client process的两个类。</p>
<p>这两个类规定了如何parcel函数调用的参数。</p>
<p>其中</p>
<ul>
<li>stub类继承了ibinder，他就是常说的binder 对象,这一层是用来和transaction数据打交道的，把从C++ middle ware层收到的parcel参数转化为java 类型供上面的service的真正的实现使用的</li>
<li>proxy类拥有stub对象的引用service，也就是binder的引用(实际在放入transaction的时候是binder token)，他负责当client调用service.func的时候把参数进行parcel放入transcation然后传入C++ middleware层</li>
</ul>
<p>那么AIDL的作用就是:</p>
<p>你负责提供一个service的interface，也就是各个函数的声明(指示了参数类型，返回值类型，函数名)。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">package com.marakana.android.fibonaccicommon;import com.marakana.android.fibonaccicommon.FibonacciRequest; </span><br><span class="line">import com.marakana.android.fibonaccicommon.FibonacciResponse;</span><br><span class="line"><span class="keyword">interface</span> <span class="title">IFibonacciService</span> &#123;	<span class="function"><span class="keyword">long</span> <span class="title">fibJR</span>(<span class="params"><span class="keyword">in</span> <span class="keyword">long</span> n</span>)</span>;	<span class="function"><span class="keyword">long</span> <span class="title">fibJI</span>(<span class="params"><span class="keyword">in</span> <span class="keyword">long</span> n</span>)</span>;	<span class="function"><span class="keyword">long</span> <span class="title">fibNR</span>(<span class="params"><span class="keyword">in</span> <span class="keyword">long</span> n</span>)</span>;	<span class="function"><span class="keyword">long</span> <span class="title">fibNI</span>(<span class="params"><span class="keyword">in</span> <span class="keyword">long</span> n</span>)</span>;	<span class="function">FibonacciResponse <span class="title">fib</span>(<span class="params"><span class="keyword">in</span> FibonacciRequest request</span>)</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>然后AIDL根据这个Interface就自动帮你生成上面的stub和proxy两个类(那两个类确实也只需要这些信息，他们的作用只是为这些类型提供parcel化而已)</p>
<p>所以AIDL的全称叫Android Interface Definition Language。<br>确实只是定义了一个interface而已。</p>
<h4 id="AIDL_u7684_u5177_u4F53_u64CD_u4F5C"><a href="#AIDL_u7684_u5177_u4F53_u64CD_u4F5C" class="headerlink" title="AIDL的具体操作"></a>AIDL的具体操作</h4><ol>
<li>java统计目录新键一个aild package（上面的例子直接叫fibonaccicommon了）</li>
<li>在这个package下新键一个.aidl文件,在里面声明接口</li>
<li>像上面那个例子用到了自定义的对象(FibonacciRequest和response)，那么就要Import这个类，同时要注意这个model类要implements parcelable才可以，上面一直强调了。</li>
<li>这个.aidl文件不只在server的app中要有，在client那边也必须要有个一样的。因为生成的类既有service process调用的stub又有client要调用的proxy.</li>
<li>build即可自动生成含有sutb和proxy的类了</li>
</ol>
<p>上面有写一个大致的自动生成的框架，今天刚好在网上看到了一个国内博客的<a href="http://android.jobbole.com/83957/" target="_blank" rel="external">Android 手写 Binder 教你理解 android 中的进程间通信-希尔瓦娜斯女神</a>，例子比较实在:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> others;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by raymond on 7/24/16.</span><br><span class="line"> */</span></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * This file is auto-generated.  DO NOT MODIFY.</span><br><span class="line"> * Original file: C:\\Users\\Administrator\\WriteBinderCodeExample\\app\\src\\main\\aidl\\com\\example\\administrator\\writebindercodeexample\\IPersonManager.aidl</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">package</span> com.example.administrator.writebindercodeexample;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IPersonManager</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">IInterface</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Local-side IPC implementation stub class.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">example</span>.<span class="title">administrator</span>.<span class="title">writebindercodeexample</span>.<span class="title">IPersonManager</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String DESCRIPTOR = <span class="string">"com.example.administrator.writebindercodeexample.IPersonManager"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Construct the stub at attach it to the interface.</span><br><span class="line">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Stub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.attachInterface(<span class="keyword">this</span>, DESCRIPTOR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Cast an IBinder object into an com.example.administrator.writebindercodeexample.IPersonManager interface,</span><br><span class="line">         * generating a proxy if needed.</span><br><span class="line">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> com.example.administrator.writebindercodeexample.<span class="function">IPersonManager <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> ((obj == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">            <span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> com.example.administrator.writebindercodeexample.IPersonManager))) &#123;</span><br><span class="line">                <span class="keyword">return</span> ((com.example.administrator.writebindercodeexample.IPersonManager) iin);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> com.example.administrator.writebindercodeexample.IPersonManager.Stub.Proxy(obj);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">                <span class="keyword">case</span> INTERFACE_TRANSACTION: &#123;</span><br><span class="line">                    reply.writeString(DESCRIPTOR);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> TRANSACTION_getPersonList: &#123;</span><br><span class="line">                    data.enforceInterface(DESCRIPTOR);</span><br><span class="line">                    java.util.List&lt;com.example.administrator.writebindercodeexample.Person&gt; _result = <span class="keyword">this</span>.getPersonList();</span><br><span class="line">                    reply.writeNoException();</span><br><span class="line">                    reply.writeTypedList(_result);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> TRANSACTION_addPerson: &#123;</span><br><span class="line">                    data.enforceInterface(DESCRIPTOR);</span><br><span class="line">                    com.example.administrator.writebindercodeexample.Person _arg0;</span><br><span class="line">                    <span class="keyword">if</span> ((<span class="number">0</span> != data.readInt())) &#123;</span><br><span class="line">                        _arg0 = com.example.administrator.writebindercodeexample.Person.CREATOR.createFromParcel(data);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        _arg0 = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">this</span>.addPerson(_arg0);</span><br><span class="line">                    reply.writeNoException();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">example</span>.<span class="title">administrator</span>.<span class="title">writebindercodeexample</span>.<span class="title">IPersonManager</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> android.os.IBinder mRemote;</span><br><span class="line"></span><br><span class="line">            Proxy(android.os.IBinder remote) &#123;</span><br><span class="line">                mRemote = remote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mRemote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getInterfaceDescriptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> DESCRIPTOR;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="keyword">public</span> java.util.List&lt;com.example.administrator.writebindercodeexample.Person&gt; getPersonList() <span class="keyword">throws</span> android.os.RemoteException &#123;</span><br><span class="line">                android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">                android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">                java.util.List&lt;com.example.administrator.writebindercodeexample.Person&gt; _result;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_getPersonList, _data, _reply, <span class="number">0</span>);</span><br><span class="line">                    _reply.readException();</span><br><span class="line">                    _result = _reply.createTypedArrayList(com.example.administrator.writebindercodeexample.Person.CREATOR);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> _result;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPerson</span><span class="params">(com.example.administrator.writebindercodeexample.Person person)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">                android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">                android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                    <span class="keyword">if</span> ((person != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                        _data.writeInt(<span class="number">1</span>);</span><br><span class="line">                        person.writeToParcel(_data, <span class="number">0</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        _data.writeInt(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_addPerson, _data, _reply, <span class="number">0</span>);</span><br><span class="line">                    _reply.readException();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_getPersonList = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_addPerson = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> java.util.List&lt;com.example.administrator.writebindercodeexample.Person&gt; getPersonList() <span class="keyword">throws</span> android.os.RemoteException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPerson</span><span class="params">(com.example.administrator.writebindercodeexample.Person person)</span> <span class="keyword">throws</span> android.os.RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较明显可以看到stub和proxy都是以子类的形式生成。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.os.SystemClock;<span class="keyword">import</span> android.util.Log;<span class="keyword">import</span> com.marakana.android.fibonaccicommon.FibonacciRequest; </span><br><span class="line"><span class="keyword">import</span> com.marakana.android.fibonaccicommon.FibonacciResponse; </span><br><span class="line"><span class="keyword">import</span> com.marakana.android.fibonaccicommon.IFibonacciService; </span><br><span class="line"><span class="keyword">import</span> com.marakana.android.fibonaccinative.FibLib;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IFibonacciServiceImpl</span> <span class="keyword">extends</span> <span class="title">IFibonacciService</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"IFibonacciServiceImpl"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">long</span> <span class="title">fibJI</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, String.format(<span class="string">"fibJI(%d)"</span>, n));</span><br><span class="line">        <span class="function"><span class="keyword">return</span> FibLib.<span class="title">fibJI</span><span class="params">(n)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">long</span> <span class="title">fibJR</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, String.format(<span class="string">"fibJR(%d)"</span>, n));</span><br><span class="line">        <span class="function"><span class="keyword">return</span> FibLib.<span class="title">fibJR</span><span class="params">(n)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">long</span> <span class="title">fibNI</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, String.format(<span class="string">"fibNI(%d)"</span>, n));</span><br><span class="line">        <span class="function"><span class="keyword">return</span> FibLib.<span class="title">fibNI</span><span class="params">(n)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">long</span> <span class="title">fibNR</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, String.format(<span class="string">"fibNR(%d)"</span>, n));</span><br><span class="line">        <span class="function"><span class="keyword">return</span> FibLib.<span class="title">fibNR</span><span class="params">(n)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function">FibonacciResponse <span class="title">fib</span><span class="params">(FibonacciRequest request)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG,</span><br><span class="line">                String.format(<span class="string">"fib(%d, %s)"</span>, request.getN(), request.getType()));</span><br><span class="line">        <span class="keyword">long</span> timeInMillis = SystemClock.uptimeMillis();</span><br><span class="line">        <span class="keyword">long</span> result;</span><br><span class="line">        <span class="keyword">switch</span> (request.getType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> ITERATIVE_JAVA:</span><br><span class="line">                result = <span class="keyword">this</span>.fibJI(request.getN());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RECURSIVE_JAVA:</span><br><span class="line">                result = <span class="keyword">this</span>.fibJR(request.getN());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ITERATIVE_NATIVE:</span><br><span class="line">                result = <span class="keyword">this</span>.fibNI(request.getN());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RECURSIVE_NATIVE:</span><br><span class="line">                result = <span class="keyword">this</span>.fibNR(request.getN());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        timeInMillis = SystemClock.uptimeMillis() - timeInMillis;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FibonacciResponse(result, timeInMillis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我这里偷懒又回到了slides中的那个例子，这里就是在真正实现service 之前，又垫一层serviceimpl类,这个类是真正实现service功能的类，这里的fibonacci函数是调用的一个<code>com.marakana.android.fibonaccinative.FibLib</code>专门的库的类的函数来实现相关功能。</p>
<p>然后</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.marakana.android.fibonacciservice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Service;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.os.IBinder;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FibonacciService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123; <span class="comment">// private static final String TAG = "FibonacciService"; private IFibonacciServiceImpl service; //</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        <span class="keyword">this</span>.service = <span class="keyword">new</span> IFibonacciServiceImpl(); <span class="comment">// Log.d(TAG, "onCreate()'ed"); //</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function">IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"onBind()'ed"</span>); <span class="comment">//</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.service; <span class="comment">// &#125;</span></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onUnbind</span> <span class="params">(Intent intent)</span></span>&#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"onUnbind()'ed"</span>); <span class="comment">//</span></span><br><span class="line">            <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">onUnbind</span><span class="params">(intent)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onDestroy</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"onDestroy()'ed"</span>);</span><br><span class="line">            <span class="keyword">this</span>.service = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>终于到了我们之前在service里已经见过的正常的service的供app直接调用的service的类的实现了，这里onBind,onUnbind这些函数都是继承service应该实现的类。用来用作回调。</p>
<h3 id="Async_Binder_IPC"><a href="#Async_Binder_IPC" class="headerlink" title="Async Binder IPC"></a>Async Binder IPC</h3><p>前面我们分析过了之前讲的全是阻塞式的binder，也是就client要等待service返回，其中ioctl一直会挂起等待。</p>
<p>这里来看看如何生成异步的bidner IPC.</p>
<p>其实最好肯定是看代码,还是上面那个slides讲得不要更清楚。但是这里真的不能再贴代码了。。。。</p>
<p>原理很好理解，就是在写你再写一个interface叫IFibonacciServiceResponseListener,也就是说在client端调用service的函数的时候都要传一个这个listener的对象作为参数，这个对象当然是在client端生成并且实现的。</p>
<p>然后等到service执行完函数后，他没有return reuslt这种语句，而是调用listenr的onResponse这个回调函数。</p>
<p>看到这里明白了</p>
<p>对!service居然也在远程调用一个client对象(listener)。</p>
<p>要怎么实现?也用BInder啊!!所以解决办法就是用相同的办法去写listener和service的aidl，然后同时生成他俩的各种stub，proxy这些，总之就是listenr这个也是个服务对象了。</p>
<p>所以我们同时要写两个aidl文件:</p>
<p>唯一区别就是要在aidl文件中声明interface的时候要加上关键字oneway：</p>
<p>文件FibonacciCommon/src/com/marakana/android/fibonaccicommon/IFibonacciServiceResponseListener.aidl:</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">oneway <span class="keyword">interface</span> <span class="title">IFibonacciServiceResponseListener</span> &#123; </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">onResponse</span>(<span class="params"><span class="keyword">in</span> FibonacciResponse response</span>)</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>文件FibonacciCommon/src/com/marakana/android/fibonaccicommon/IFibonacciService.aidl:</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oneway <span class="keyword">interface</span> <span class="title">IFibonacciService</span> &#123;	<span class="function"><span class="keyword">void</span> <span class="title">fib</span>(<span class="params"><span class="keyword">in</span> FibonacciRequest request, <span class="keyword">in</span> IFibonacciServiceResponseListener listener</span>)</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>我想这个oneway的作用就是告诉ioctl不用挂起等待吧。一次性结束，当service要调用client的函数的时候他自己会重新走一遍进程间的通信流程。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>并没有找到讲binder机制特别清晰的中文资料</p>
<p>终于在youtube上找到一个<a href="https://www.youtube.com/watch?v=Jgampt1DOak">演讲</a>和<a href="http://events.linuxfoundation.org/images/stories/slides/abs2013_gargentas.pdf">slides</a>,以及<a href="https://www.nds.rub.de/media/attachments/files/2012/03/binder.pdf">这篇</a>资料作为补充，从更全面的角度介绍了更细致的前因后果的</p>]]>
    
    </summary>
    
      <category term="java，Android" scheme="http://potatoker.github.io/tags/java%EF%BC%8CAndroid/"/>
    
      <category term="Android" scheme="http://potatoker.github.io/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[图片OOM]]></title>
    <link href="http://potatoker.github.io/2016/08/16/OOM/"/>
    <id>http://potatoker.github.io/2016/08/16/OOM/</id>
    <published>2016-08-16T01:20:30.000Z</published>
    <updated>2016-08-17T03:55:00.252Z</updated>
    <content type="html"><![CDATA[<p>之前在超狗的测试中在中低端型机上遇到了图片问题造成的OOM，虽然最后还是用resize的方式解决的，这里还是整理一下当时遇到的一些问题。</p>
<a id="more"></a> 
<h2 id="u4E00_u4E2A_u4E8B_u5B9E_uFF1A"><a href="#u4E00_u4E2A_u4E8B_u5B9E_uFF1A" class="headerlink" title="一个事实："></a>一个事实：</h2><blockquote>
<p>On Android 2.3.3 (API level 10) and lower, the backing pixel data for a bitmap is stored in native memory. It is separate from the bitmap itself, which is stored in the Dalvik heap. The pixel data in native memory is not released in a predictable manner, potentially causing an application to briefly exceed its memory limits and crash. As of Android 3.0 (API level 11), the pixel data is stored on the Dalvik heap along with the associated bitmap.</p>
</blockquote>
<h2 id="u4E0D_u540C_u7248_u672C_u5BF9bitmap_u5B58_u50A8_u7BA1_u7406_u7684_u4E0D_u540C_u5904_u7406_3A"><a href="#u4E0D_u540C_u7248_u672C_u5BF9bitmap_u5B58_u50A8_u7BA1_u7406_u7684_u4E0D_u540C_u5904_u7406_3A" class="headerlink" title="不同版本对bitmap存储管理的不同处理:"></a>不同版本对bitmap存储管理的不同处理:</h2><p> 首先，说一下Android 2.3–2.3.7 “Gingerbread”和其以后的android版本的区别:</p>
<blockquote>
<p>On Android Android 2.2 (API level 8) and lower, when garbage collection occurs, your app’s threads get stopped. This causes a lag that can degrade performance. Android 2.3 adds concurrent garbage collection, which means that the memory is reclaimed soon after a bitmap is no longer referenced.</p>
<p>On Android 2.3.3 (API level 10) and lower, the backing pixel data for a bitmap is stored in native memory. It is separate from the bitmap itself, which is stored in the Dalvik heap. The pixel data in native memory is not released in a predictable manner, potentially causing an application to briefly exceed its memory limits and crash. As of Android 3.0 (API level 11), the pixel data is stored on the Dalvik heap along with the associated bitmap.</p>
</blockquote>
<p> 就是说，在android2.3.3之前，有关于bitmap的两个显著不同:</p>
<h3 id="Android3-0_u4E4B_u524D_2Cbitmap_pixel_data_u5B58_u5728ashmem_u91CC_u9762"><a href="#Android3-0_u4E4B_u524D_2Cbitmap_pixel_data_u5B58_u5728ashmem_u91CC_u9762" class="headerlink" title="Android3.0之前,bitmap pixel data存在ashmem里面"></a>Android3.0之前,bitmap pixel data存在ashmem里面</h3><ol>
<li>在android2.3.3之前，bitmap这个对象的存储，和bitmap pixel的存储是分开的！bitmap对象是存在heap上的(图的大小啊，pixel的位置信息等),然而真正的图像(pixel)是存储在ashmen里面的，属于native区域。我们知道java GC的原理是根据引用的GC root，可是你就会发现这里图像pixel压根不算做对象，也没有引用，他只是单纯的占用了一块内存区域，所以平常的GC root判断GC的方法对在ashmen里面的pixel来说没用，所以需要系统或者我们自己来对这块区域的内存做恰当的管理。</li>
</ol>
<h4 id="ahmem_u5230_u5E95_u662F_u4EC0_u4E48"><a href="#ahmem_u5230_u5E95_u662F_u4EC0_u4E48" class="headerlink" title="ahmem到底是什么"></a>ahmem到底是什么</h4><blockquote>
<p>在Android系统中，提供了独特的匿名共享内存子系统Ashmem（Anonymous Shared Memory），它以驱动程序的形式实现在内核空间中。</p>
</blockquote>
<p> 原来asmem存在于内核空间，不属于任何一个单个jvm的一部分，但是，在查阅资料中发现:</p>
<blockquote>
<p>the GB Dalvik VM adds the sizes of both the Java and native heaps when determining if the app will exceed the max heap size for the app, which is device specific.</p>
</blockquote>
<p>也就是说系统也规定了这个process使用native区域的大小，要是和java heap加起来的大小来算OOM的。</p>
<p>也就是说如果ashmem管理不当，也有可能会OOM,应该是非常可能发生OOM,因为正常的java gc方法在这块区域不被使用。</p>
<p><a href="http://blog.csdn.net/luoshengyang/article/details/6664554" target="_blank" rel="external">Android系统匿名共享内存Ashmem（Anonymous Shared Memory）驱动程序源代码分析-罗升阳</a>介绍:</p>
<blockquote>
<p>它向Linux内存管理系统的内存回收算法注册接口，告诉Linux内存管理系统它的某些内存块不再使用了，可以被回收了，不过，这些不再使用的内存需要由它的使用者来告诉Ashmem驱动程序。通过这种用户-Ashmem驱动程序-内存管理系统三者的紧密合作，实现有效的内存管理机制，适合移动设备小内存的特点。</p>
</blockquote>
<h5 id="shmem_u5185_u5B58_u662F_u600E_u4E48_u88AB_u7BA1_u7406_u7684"><a href="#shmem_u5185_u5B58_u662F_u600E_u4E48_u88AB_u7BA1_u7406_u7684" class="headerlink" title="shmem内存是怎么被管理的"></a>shmem内存是怎么被管理的</h5><p>回到最开始的问题，那在2.3之前，系统是怎么判断清除ahsmem不用的内存的呢？</p>
<p>看<a href="http://stackoverflow.com/questions/3823799/android-bitmap-recycle-how-does-it-work" target="_blank" rel="external">SO</a>的解释:</p>
<blockquote>
<p>I think the problem is this: On pre-Honeycomb versions of Android, the actual raw bitmap data is not stored in VM memory but in native memory instead. This native memory is freed when the corresponding java Bitmap object is GC’d.</p>
<p>However, when you run out of native memory, the dalvik GC isn’t triggered, so it is possible that your app uses very little of the java memory, so the dalvik GC is never invoked, yet it uses tons of native memory for bitmaps which eventually causes an OOM error.</p>
</blockquote>
<p>我觉得系统默认的管理ahsmem中pixel的方式是，如果bitmap对象被GC了，那么对应的ashmem也被清除。</p>
<p>看起来挺好的，可是有没有一种情况是，java heap里面空间很松散，有几个bitmap对象而已，即使这些bitmp对象被标记为可清除了，可是因为空间很足，GC<br>是很可能很长时间不会被触发的。可是asmeme中的区域可能已经被占用很大啊。那么OOM很可能会发生。</p>
<p>那只能手动的去管理。有两个办法:</p>
<ol>
<li><p>调用Bitmap.recycle()<br> 这也是官网上说的办法:</p>
<blockquote>
<p>On Android 2.3.3 (API level 10) and lower, using recycle() is recommended. If you’re displaying large amounts of bitmap data in your app, you’re likely to run into OutOfMemoryError errors. The recycle() method allows an app to reclaim memory as soon as possible.</p>
</blockquote>
</li>
<li><p>使用finalizer</p>
</li>
</ol>
<blockquote>
<p>The finalize method is called when an object is about to get garbage collected. That can be at any time after it has become eligible for garbage collection.</p>
<p>finalize should only be used for cleanup of (usually non-Java) resources. And that’s exactly because the JVM doesn’t guarantee that finalize is ever called on any object.</p>
</blockquote>
<p>都是清除内存的方式。</p>
<p>其实比较官方的还是用Bitmap.recycle(),要自定义实现使用引用计数法，去判断何时应该去recycle一个bitmap对象。这个是官网对于图片处理的例子。</p>
<p>在2.3以下，不能靠GC root的方法去判断GC一个bitmap pixel，要人工的去使用引用计数法，使用recycle()函数去释放着块内存，非常的琐碎。人工的去进行内存管理可能出问题，其实这时候已经像C++一样去操作内存了。</p>
<h3 id="Android_2-3_u4E4B_u524D_uFF0CGC_u65B9_u5F0F_u4E0D_u662Fcocurrent_GC"><a href="#Android_2-3_u4E4B_u524D_uFF0CGC_u65B9_u5F0F_u4E0D_u662Fcocurrent_GC" class="headerlink" title="Android 2.3之前，GC方式不是cocurrent GC"></a>Android 2.3之前，GC方式不是cocurrent GC</h3><p>再来看第二个:</p>
<ol>
<li>On Android Android 2.2 (API level 8) and lower, when garbage collection occurs, your app’s threads get stopped. This causes a lag that can degrade performance. Android 2.3 adds concurrent garbage collection, which means that the memory is reclaimed soon after a bitmap is no longer referenced.</li>
</ol>
<p>可以在JVM一篇回忆几种垃圾回收器。</p>
<p>开始时没明白这里强调垃圾回收机制的变化和ashmem以及OOM有啥关系，他这里暗示说:</p>
<blockquote>
<p>which means that the memory is reclaimed soon after a bitmap is no longer referenced.</p>
</blockquote>
<p>拿到coccurent GC是即时回收的？如果是即时回收的话，确实可以作为2.2之前容易产生ashmem OOM的原因，因为还是上面那个例子，因为heap里面的不及时回收导致了ashmem的OOM，有了即时回收，就可以很大程度上解决GC卡顿或者OOM的问题。</p>
<p>另外dalvik的 coccurent GC 垃圾回收算法采用的是标记清除算法(没错，最简单那种)，到了ART，则使用了标记整理，这些垃圾回收机制的升级都一定程度上缓解了OOM或者频繁GC的卡顿问题。</p>
<h3 id="android3-0_u4EE5_u540E_28bitmap_u5B8C_u5168_u5728hava_heap_29_u7684_u95EE_u9898"><a href="#android3-0_u4EE5_u540E_28bitmap_u5B8C_u5168_u5728hava_heap_29_u7684_u95EE_u9898" class="headerlink" title="android3.0以后(bitmap完全在hava heap)的问题"></a>android3.0以后(bitmap完全在hava heap)的问题</h3><p>然而我们再来看一遍fresco的介绍:</p>
<blockquote>
<p>解压后的图片，即Android中的Bitmap，占用大量的内存。大的内存占用势必引发更加频繁的GC。在5.0以下，GC将会显著地引发界面卡顿。</p>
<p>在5.0以下系统，Fresco将图片放到一个特别的内存区域。当然，在图片不显示的时候，占用的内存会自动被释放。这会使得APP更加流畅，减少因图片内存占用而引发的OOM。</p>
</blockquote>
<p>为什么特别提到了5.0以下呢,不是ashmem的问题在3.0中就已经解决了吗，3.0的时候不仅已经把pixel放到heap了，垃圾收集器也进化了，问题是不是算是解决了?</p>
<h4 id="bimap_u5BF9_u8C61_u590D_u7528_u6765_u89E3_u51B3_u9891_u7E41GC"><a href="#bimap_u5BF9_u8C61_u590D_u7528_u6765_u89E3_u51B3_u9891_u7E41GC" class="headerlink" title="bimap对象复用来解决频繁GC"></a>bimap对象复用来解决频繁GC</h4><p>上面说了，bitmap太大的时候回引发频繁的GC，会造成系统卡顿，那么怎么解决呢?</p>
<blockquote>
<p>Android 3.0 (API level 11) introduces the BitmapFactory.Options.inBitmap field. If this option is set, decode methods that take the Options object will attempt to reuse an existing bitmap when loading content. This means that the bitmap’s memory is reused, resulting in improved performance, and removing both memory allocation and de-allocation</p>
</blockquote>
<p>哦，原来安卓官方搞了一个inBitmap的的option用来标记一个Bitmap对象是可被复用的，就像listview的convertview一样。这样就减少了GC，还减少了construction和desconstruction的时间。问题解决了。</p>
<p>既然这样，fresco有何用?</p>
<p>解释这个之前，先看这个:</p>
<blockquote>
<p>However, there are certain restrictions with how inBitmap can be used. In particular, before Android 4.4 (API level 19), only equal sized bitmaps are supported.</p>
</blockquote>
<p>原来是有限制的。重用的bitmap要有相同的大小，恩，就和listView里，重用的items layout结构也必须是一样的。</p>
<p>也就是说4.4之前的都不太可能用好这个性质，bitmap还是会引发频繁的GC咯。</p>
<p>这里概括几个版本对bitmap处理的问题:</p>
<ol>
<li>3.0之前<ol>
<li>bitmap的pixel放在ashmem里面，属于native区域，pixel区域的回收需要heap里面bitmap对象的回收，然而由于GC的延迟性，即使bitmap不被需要，也不会被马上回收，bitmap对象是不叫小，但pixel很大，所以会造成OOM</li>
<li>android 2.3之前，回收器不是cocurren GC，文档暗示说cocurrent GC会比较快的回收不需要的bitmap对象。所以2.3之前这个问题更严重。</li>
</ol>
</li>
</ol>
<ol>
<li>4.4之前<br> bitmap的pixel也放到了java heap里面。虽然BitmapFactory.Options.inBitmap这个选项这可以对bitmap对象进行复用，减少频繁GC带来的卡顿，但是这个版本这一功能只可以对相同大小的bitmap对象复用，这无疑是一个很大的限制</li>
</ol>
<ol>
<li>4.4之后<br> 4.4之后官方修复了只能对相同大小bitmap服用的的限制。</li>
</ol>
<p>所以可以看出来4.4之后已有的办法，才算是对Bitmap的存储做了一个比较好的处理.</p>
<p>这也是为什么freso一直在针对5.0以下的版本在说。</p>
<h2 id="fresco_u5BF9bitmap_u7684_u5904_u7406_u65B9_u5F0F"><a href="#fresco_u5BF9bitmap_u7684_u5904_u7406_u65B9_u5F0F" class="headerlink" title="fresco对bitmap的处理方式"></a>fresco对bitmap的处理方式</h2><p>那么fresco到底是怎么对5.0以下版本进行Bitmap存储优化的呢?</p>
<p>还是看文档介绍的:</p>
<blockquote>
<p>在5.0以下系统，Fresco将图片放到一个特别的内存区域。当然，在图片不显示的时候，占用的内存会自动被释放。这会使得APP更加流畅，减少因图片内存占用而引发的OOM。</p>
</blockquote>
<p>加上之前的关于ashmem的介绍差不多可以理解了</p>
<p>fresco使用的核心是使用了自定义Drawable类。这个类和ashmem中pixel data的管理息息相关，这里稍微扫了眼源码，这个类确实有采用引用计数法对其成员变量进行管理，这里应该就是图片数据的引用了。</p>
<p>其实可以看到前面的ahmem的做法，无非就是有一个问题，就是当实际上这个bitmap pixel是不被需要的时候，系统自己是没办法马上就把ahsmem这部分给清除的。那只要我自己能够很快地清除他，不久完美解决了吗。</p>
<p>所以我觉得fresco的思路是，他会把bitmap的pixel还是放在ashmem区域，但是和系统不一样的是，他会自己来好好地处理这一块区域，因为这一块区域是linux kernel 区域，应该是可以调用本地C++清除方式，比如上面的recycle应该就是一种C++的清除方式，可以立即清除，也许fresco就是用的recycle方法，或者使用native方法接口来做垃圾回收。</p>
<p>另外fresco的这个好处我觉得也确实是他说的，使用一套方案解决了不同机型bitmap问题，否则要是真的按系统方法，必须要不停地去判断，然后采取对应这个系统版本的bitmap处理方法。</p>
<h2 id="fresco_u7684_u7279_u70B9_u603B_u7ED3"><a href="#fresco_u7684_u7279_u70B9_u603B_u7ED3" class="headerlink" title="fresco的特点总结"></a>fresco的特点总结</h2><p>这里看一下fresco的特点</p>
<ol>
<li>三级缓存，当然其他的库很多也做到了</li>
</ol>
<p>一般的图片的比较完善的缓存机制:</p>
<p><img src="/images/fresco.png" alt=""></p>
<ol>
<li>利用ashmem</li>
</ol>
<blockquote>
<p>在5.0系统以下，Image Pipeline 使用`pinned purgeables*将Bitmap数据避开Java堆内存，存在ashmem中。这要求图片不使用时，要显式地释放内存。</p>
<p>SimpleDraweeView 自动处理了这个释放过程，所以没有特殊情况，尽量使用SimpleDraweeView，在特殊的场合，如果有需要，也可以直接控制Image Pipeline。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前在超狗的测试中在中低端型机上遇到了图片问题造成的OOM，虽然最后还是用resize的方式解决的，这里还是整理一下当时遇到的一些问题。</p>]]>
    
    </summary>
    
      <category term="java，Android" scheme="http://potatoker.github.io/tags/java%EF%BC%8CAndroid/"/>
    
      <category term="Android" scheme="http://potatoker.github.io/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[单例]]></title>
    <link href="http://potatoker.github.io/2016/05/17/%E5%8D%95%E4%BE%8B/"/>
    <id>http://potatoker.github.io/2016/05/17/单例/</id>
    <published>2016-05-17T02:38:30.000Z</published>
    <updated>2016-08-17T03:42:56.130Z</updated>
    <content type="html"><![CDATA[<p>最近复习，顺藤摸瓜的对一些java基础进行了巩固。</p>
<a id="more"></a>
<p>首先，在所有的解释中<a href="http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/" target="_blank" rel="external">如何正确地写出单例模式-黑桃夹克</a>是比较详细的，多有参考。</p>
<p>首先单例分为懒汉式和饿汉式</p>
<p>分类的区别在于:</p>
<p>懒汉式:单例是在需要的时候才会被初始化(相对饿汉式来说初始化被推迟了，所以称为”懒汉式”)<br>饿汉式:单例在类被加载的会后就被初始化</p>
<p>另外，不同的实现又分为线程安全和线程不安全:</p>
<p>目前来讲，实现线程安全的方式，就是使用synchronized关键字。<br>为什么线程安全要被提出，因为，作为单例，程序里只有一个实例，那么如果这是一个多线程的程序的话，很容易出现多线程同时访问同一个实例的同步问题。</p>
<h2 id="1-__u61D2_u6C49_u5F0F_uFF0C_u7EBF_u7A0B_u4E0D_u5B89_u5168"><a href="#1-__u61D2_u6C49_u5F0F_uFF0C_u7EBF_u7A0B_u4E0D_u5B89_u5168" class="headerlink" title="1. 懒汉式，线程不安全"></a>1. 懒汉式，线程不安全</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">         instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到是通过调用<code>getInstance</code>的时候才初始化的，同时，要在调用的时候检验单例是否初始化，如果已经初始过，自然不需要初始化。</p>
<h2 id="2-__u61D2_u6C49_u5F0F_uFF0C_u7EBF_u7A0B_u5B89_u5168"><a href="#2-__u61D2_u6C49_u5F0F_uFF0C_u7EBF_u7A0B_u5B89_u5168" class="headerlink" title="2. 懒汉式，线程安全"></a>2. 懒汉式，线程安全</h2><p>然而上面的是线程不安全的，所有线程可以同时拿到单例，并进行操作，这种同时操作如果有需要同步的写操作的话，自然会造成紊乱。</p>
<p>那么这里很简单的想法，就是把这个<code>getInstance</code>函数变成线程同步的。这样就不允许多个线程同时拿到单例的情况发生了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-__u61D2_u6C49_u5F0F_uFF0C_u7EBF_u7A0B_u5B89_u5168_uFF0C_u53CC_u91CD_u68C0_u9A8C_u9501"><a href="#3-__u61D2_u6C49_u5F0F_uFF0C_u7EBF_u7A0B_u5B89_u5168_uFF0C_u53CC_u91CD_u68C0_u9A8C_u9501" class="headerlink" title="3. 懒汉式，线程安全，双重检验锁"></a>3. 懒汉式，线程安全，双重检验锁</h2><p>然而上面的最简单的懒汉式有个问题，就是很有可能有一种情况，就是，其实是允许大家同时对单例进行读或写的操作的，最典型的例子，是volley，大家只是想拿到单例往里面的队列放任务而已，而入队操作本来就允许多个线程同时执行啊。</p>
<p>所以这种需求下，我唯一需要同步的部分是<code>getInstance</code>函数里面，当我要进行单例初始化操作的时候，这个操作肯定是需要同步的。</p>
<p>那么就有了双重检验锁的诞生:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;                         <span class="comment">//Single Checked</span></span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;                 <span class="comment">//Double Checked</span></span><br><span class="line">                instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，复习一下<code>synchronized (Singleton.class)</code>,如果要同步整个成员函数，那么synchronized的内部锁其实是<code>this</code>，可是如果要同步一个静态函数(没有this调用),那么内部锁是类对象，即<code>Singleton.class</code></p>
<h4 id="volatile_u5173_u952E_u5B57"><a href="#volatile_u5173_u952E_u5B57" class="headerlink" title="volatile关键字"></a>volatile关键字</h4><p>然而，这个程序是不完全的！！！</p>
<p>错误点的解释:</p>
<ol>
<li>初始化一个对象的操作并不是在一瞬间完成的，他是由多条指令构成的</li>
<li>java中的语句可能是由多条指令构成的，然而编译器可能对这一条语句对应的多条指令进行指令重排进行执行优化</li>
<li>在上面的程序里，考虑一种情况：线程1第一个调用getSingleton,由他来进行初始化，然而这个初始化过程，包括给(1)给Singleton在heap中划分空间，把地址传给引用(2)初始化其成员变量…等等，</li>
<li>有可能是引用已经不为空，但是实际上对象还没有初始化好的情况。在这个时间点，如果有线程2来调用Singleton，他会发现引用已经不为空，不会进入同步的初始化单例的语句，而是直接读这个单例了，但实际上这个单例根本还没被初始化好。</li>
</ol>
<p>网上基本上解释为指令重排带来的错误，我这里觉得有可能是分配引用和真正construct这块引起的问题。</p>
<p>那么解决办法是?<br><strong>使用volatile关键字标识对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance; <span class="comment">//声明成 volatile</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;                         </span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;       </span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>volitile关键字会保证该变量的操作一定是满足happens-before原则</p>
<p>通过保证:</p>
<ol>
<li>所有线程的读写都是在main memory进行，不会是在cache中进行</li>
<li>对该变量的操作屏蔽了指令重排</li>
</ol>
<p><a href="http://stackoverflow.com/questions/11639746/what-is-the-point-of-making-the-singleton-instance-volatile-while-using-double-l" target="_blank" rel="external">SO</a><br>中的解释</p>
<blockquote>
<p>The volatile prevents memory writes from being re-ordered, making it impossible for other threads to read uninitialized fields of your singleton through the singleton’s pointer.</p>
<p>Consider this situation: thread A discovers that uniqueInstance == null, locks, confirms that it’s still null, and calls singleton’s constructor. The constructor makes a write into member XYZ inside Singleton, and returns. Thread A now writes the reference to the newly created singleton into uniqueInstance, and gets ready to release its lock.</p>
<p>Just as thread A gets ready to release its lock, thread B comes along, and discovers that uniqueInstance is not null. Thread B accesses uniqueInstance.XYZ thinking that it has been initialized, but because the CPU has reordered writes, the data that thread A has written into XYZ has not been made visible to thread B. Therefore, thread B sees an incorrect value inside XYZ, which is wrong.</p>
<p>When you mark uniqueInstance volatile, a memory barrier is inserted. All writes initiated prior to that of uniqueInstance will be completed before the uniqueInstance is modified, preventing the reordering situation described above.</p>
</blockquote>
<p>这里说的就是先分配引用再初始化的问题，这里看到了网上的另外一些更explicit的<a href="http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html" target="_blank" rel="external">说法</a>:</p>
<blockquote>
<p>As you can see, the assignment to singletons[i].reference is performed before the constructor for Singleton is called. This is completely legal under the existing Java memory model, and also legal in C and C++ (since neither of them have a memory model).</p>
</blockquote>
<h2 id="4-__u997F_u6C49_u5F0F_static_final_field"><a href="#4-__u997F_u6C49_u5F0F_static_final_field" class="headerlink" title="4. 饿汉式 static final field"></a>4. 饿汉式 static final field</h2><p>上面的懒汉式由于是推迟构造，构造这个动作要是同步的，同时读写又可能不需要同步，造成了上面那些麻烦的事情。</p>
<p>这里饿汉式就是直接把单例设为静态变量，单例的初始化是在类被加载的时候(虽然类被加载可能是由线程调用getInstance触发的)，是由jVM去完成的，而不是线程。所以线程间的初始化单例的动作是线程安全的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">//类加载时就初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里复习一下几个东西:</p>
<ol>
<li>什么时候一个类会被load</li>
<li>什么时候一个类中的static field会被初始化</li>
<li>为什么这里单例作为static field初始化时线程安全的?</li>
</ol>
<p>####对于1 ：什么时候一个类会被load</p>
<p><a href="http://www.programcreek.com/2013/01/when-and-how-a-java-class-is-loaded-and-initialized/" target="_blank" rel="external">这篇文章</a>有详细说明</p>
<blockquote>
<p>We can see the difference highlighted in red. A.class is loaded only when it is used. In summary, a class is loaded:</p>
<ul>
<li>when the new bytecode is executed. For example, SomeClass f = new SomeClass();</li>
<li>when the bytecodes make a static reference to a class. For example, System.out.</li>
</ul>
</blockquote>
<p>其实就是之前操作系统复习到的动态加载，这样才算作节省资源并且合理分配资源。</p>
<h4 id="u5BF9_u4E8E2_uFF1A_u4EC0_u4E48_u65F6_u5019_u4E00_u4E2A_u7C7B_u4E2D_u7684static_field_u4F1A_u88AB_u521D_u59CB_u5316"><a href="#u5BF9_u4E8E2_uFF1A_u4EC0_u4E48_u65F6_u5019_u4E00_u4E2A_u7C7B_u4E2D_u7684static_field_u4F1A_u88AB_u521D_u59CB_u5316" class="headerlink" title="对于2：什么时候一个类中的static field会被初始化"></a>对于2：什么时候一个类中的static field会被初始化</h4><p>首先，类的成员变量，或者说实例的成员变量，什么时候被初始化，被new的时候啊。这个不用多说，那么，主要的问题就在这个静态变量.</p>
<blockquote>
<p>After class loading, initialization of class takes place which means initializing all static members of class.</p>
</blockquote>
<p><a href="http://stackoverflow.com/questions/3499214/when-does-static-class-initialization-happen" target="_blank" rel="external">这篇SO</a>和<a href="http://javarevisited.blogspot.com/2012/07/when-class-loading-initialization-java-example.html" target="_blank" rel="external">这篇</a>有个很官方的说法</p>
<blockquote>
<p>A classes static initialization normally happens immediately before the first time one of the following events occurs:</p>
<ul>
<li>an instance of the class is created,</li>
<li>a static method of the class is invoked,</li>
<li>a static field of the class is assigned,</li>
<li>an static field of class is used which is not a constant variable.</li>
<li>for a top-level class, an assert statement lexically nested within the class is executed.</li>
</ul>
</blockquote>
<p>这不也就是动态加载那一套吗嘛.总结一下就是，<br><strong>类中的静态变量是在用到这个静态变量的时候才会被初始化的</strong></p>
<p>这个初始化包括这个静态变量所在类的加载，和这个静态变量的初始化。</p>
<p><a href="http://stackoverflow.com/questions/2007666/in-what-order-do-static-initializer-blocks-in-java-run" target="_blank" rel="external">这篇SO</a>的答案就是说的这样干脆:</p>
<blockquote>
<p>The static initializer for a class gets run when the class is first accessed, either to create an instance, or to access a static method or field.So, for multiple classes, this totally depends on the code that’s run to cause those classes to get loaded.</p>
</blockquote>
<p>所以很不严谨的用人话回答上面的那个问题:</p>
<ol>
<li>类被用于创建实例(new)或用到了成员变量的时候，反正就是被使用的时候</li>
<li>类被加载的时候</li>
</ol>
<p>最后最后回到我们的饿汉式。</p>
<p>看完了上面这些，我就会发现，这个单例作为static field，那么只有当我用到这个静态单例变量的时候才会被初始化，这不就是我们想要吗?</p>
<p>如果你的单例类，真的<strong>只有</strong>上面写的那一部分。确实，这个饿汉式就是lazy mode，即用即初始化。</p>
<p>but,你可能还有别的静态变量，别的静态函数在这个单例类里面啊。</p>
<p>而只要<strong>任何一个</strong>静态field被用到了，这个类就会被load，这个类一被load,那这个类的<strong>所有</strong>静态变量都会被初始化！！</p>
<p><a href="http://stackoverflow.com/questions/7790185/singleton-lazy-vs-eager-instantiation" target="_blank" rel="external">这篇SO</a>就是说明了这个问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;     </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Logger instance = <span class="keyword">new</span> Logger(); </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> String LOG_LINE_SEPERATOR =  </span><br><span class="line">      System.getProperty(<span class="string">"line.separator"</span>);</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Logger <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">          <span class="keyword">return</span> instance;     </span><br><span class="line">   &#125; </span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">logPattern</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Logger.LOG_LINE_SEPERATOR; <span class="comment">// load Logger instance or</span></span><br><span class="line">Logger.logPattern(); <span class="comment">// load Logger instance</span></span><br></pre></td></tr></table></figure>
<p>他这里就演示了一段有其他静态变量的单例类，然后就发现，用到这个Looger静态变量的时候，单例也被初始化了，这就不是懒汉式了，因为我们此时并不需要单例。</p>
<h4 id="u5BF9_u4E8E3_uFF0C_u4E3A_u4EC0_u4E48_u5355_u4F8B_u4F5C_u4E3Astatic_field_u88AB_u521D_u59CB_u5316_u7684_u65F6_u5019_u662F_u7EBF_u7A0B_u5B89_u5168_u7684_28_u6211_u4EEC_u81EA_u5DF1_u6CA1_u6709_u5BF9_u8FD9_u4E2A_u52A8_u4F5C_u8FDB_u884C_u540C_u6B65_u64CD_u4F5C_29"><a href="#u5BF9_u4E8E3_uFF0C_u4E3A_u4EC0_u4E48_u5355_u4F8B_u4F5C_u4E3Astatic_field_u88AB_u521D_u59CB_u5316_u7684_u65F6_u5019_u662F_u7EBF_u7A0B_u5B89_u5168_u7684_28_u6211_u4EEC_u81EA_u5DF1_u6CA1_u6709_u5BF9_u8FD9_u4E2A_u52A8_u4F5C_u8FDB_u884C_u540C_u6B65_u64CD_u4F5C_29" class="headerlink" title="对于3，为什么单例作为static field被初始化的时候是线程安全的(我们自己没有对这个动作进行同步操作)"></a>对于3，为什么单例作为static field被初始化的时候是线程安全的(我们自己没有对这个动作进行同步操作)</h4><p>因为虚拟机初始化这些静态变量的时候会自动给他们加锁，所以一定是线程安全的</p>
<blockquote>
<p>VM runs static initializer blocks and set defaults values for the static fields. This phase uses a special VM lock, one per class or interface, and is what makes singletons thread-safe</p>
</blockquote>
<h2 id="5-__u9759_u6001_u5185_u90E8_u7C7B_static_nested_class"><a href="#5-__u9759_u6001_u5185_u90E8_u7C7B_static_nested_class" class="headerlink" title="5. 静态内部类 static nested class"></a>5. 静态内部类 static nested class</h2><p>好了，看完了上面的，其实我们想要的就是线程安全的，同时是懒汉式初始化的一种单例的实现。目前能够达到这两点的只有double check，但那个方法真的看起来非常不elegent.并且对java版本有要求。</p>
<p>而只有这个方法，我觉的是满足上面两个需求，并且是懒汉式的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE; </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对比上面的饿汉式，其实在单例初始化的线程安全这一点都是用静态变量在类装载时初始化这个原理来保证的。</p>
<p>先看一个问题:</p>
<hr>
<h4 id="u5185_u90E8_u7C7B_u7684load_u662F_u5728_u4EC0_u4E48_u65F6_u5019_u53D1_u751F_u7684"><a href="#u5185_u90E8_u7C7B_u7684load_u662F_u5728_u4EC0_u4E48_u65F6_u5019_u53D1_u751F_u7684" class="headerlink" title="内部类的load是在什么时候发生的"></a>内部类的load是在什么时候发生的</h4><p>答案是，不管是静态内部类还是非静态内部类他们的Load时机完全和上面通用的类的加载是一样的.</p>
<p><a href="http://stackoverflow.com/questions/25192561/when-is-a-static-nested-class-and-static-members-therein-loaded-into-memory" target="_blank" rel="external">这篇SO</a>阐述了相同的疑问:</p>
<blockquote>
<p>There is nothing particularly special about static nested classes. They are loaded the same way as non static and/or non nested classes. To the JVM, all classes are the same and it doesn’t really understand nesting the way Java does</p>
</blockquote>
<p>那我们就知道，虽然SingletonHolder是个Singleton的内部类，但它和普通的类没什么不同，即使Singleton被load了，被初始化了，跟SingletonHolder没一点关系，SingletonHolder跟Singleton唯一的关系是，这个类的表示方式是:<br><code>Singleton$SingletonHolder</code></p>
<p>而静态内部类和非静态内部类唯一的区别是非静态内部类含有外部类实例的引用。这里我们根本不需要用到这个，而且混乱了逻辑，所以只用静态内部类。</p>
<hr>
<p><em>那么怎么实现初始化的lazy mode的呢?</em></p>
<p>上面饿汉式之所以不满足逻辑上的Lazy mode,是因为你不能保证单例类只有他那一个静态变量或者静态函数。</p>
<p>好，既然单例类可能要有别的静态变量，那我就为你这个单例实例单独创建一个类，保证这个类只有单例你一个静态变量，并且只有外面单例类的<code>getInstance</code>会用到这个静态变量(单例)。</p>
<p>这样就保证了，即使单例类有各种乱起八糟其他的静态变量啊，静态函数啊，随便用，都不会影响到单例的初始化，只有完完全全符合我们真正需求的<code>getInstance</code>会触发这个静态内部类的load以及其中单例的初始化。至此完美的达成了即用即初始化的想法。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近复习，顺藤摸瓜的对一些java基础进行了巩固。</p>]]>
    
    </summary>
    
      <category term="java，basic" scheme="http://potatoker.github.io/tags/java%EF%BC%8Cbasic/"/>
    
      <category term="java" scheme="http://potatoker.github.io/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hadoop homework]]></title>
    <link href="http://potatoker.github.io/2016/01/09/hadoop%E6%B5%81%E6%B0%B4%E8%B4%A6/"/>
    <id>http://potatoker.github.io/2016/01/09/hadoop流水账/</id>
    <published>2016-01-09T12:53:30.000Z</published>
    <updated>2016-01-09T13:13:17.236Z</updated>
    <content type="html"><![CDATA[<p>本来想要多花时间把这份作业尽量做好，结果懒癌晚期让我在deadline前两天才开始做。。。</p>
<p>其实现在自己连门都没入，不过近段时间恐怕都没有时间继续学习hadoop了，所以下次做实验最好能尽快回忆起已学的记下这篇流水账，。<br>此外发现自己对linux仍然各种不熟，，，形成了这篇本质流水账</p>
<p>project基于hadoop 1.0.4. 属于很早的版本</p>
<a id="more"></a>
<h1 id="1-_hadoop_u5B89_u88C5"><a href="#1-_hadoop_u5B89_u88C5" class="headerlink" title="1. hadoop安装"></a>1. hadoop安装</h1><p>我装的是hadoop 1.0.4,似乎hadoop几次更新改变都很大，不过作为入门，安全起见，还是使用了老师演示版本。并且也选择了对应的Jdk6</p>
<h2 id="1-__u9884_u7F6E_u8F6F_u4EF6"><a href="#1-__u9884_u7F6E_u8F6F_u4EF6" class="headerlink" title="1. 预置软件"></a>1. 预置软件</h2><h3 id="1-jdk"><a href="#1-jdk" class="headerlink" title="1.jdk"></a>1.jdk</h3><p>sudo apt-get install openjdk-6-jdk</p>
<p>安装完之后增加到环境变量</p>
<pre><code>export JAVA_HOME=/usr/lib/jvm/java-6-openjdk-amd64   

export PATH=$PATH:$JAVA_HOME/bin 
</code></pre><p>用来检查是否生效：</p>
<pre><code>javac -version  
</code></pre><h3 id="2-_ssh"><a href="#2-_ssh" class="headerlink" title="2. ssh"></a>2. ssh</h3><pre><code>sudo apt-get install ssh
</code></pre><p>查看是否启动</p>
<pre><code>$ps -e|grep ssh
</code></pre><p><em>-e Select all processes. Identical to -A.</em><br><em>-f does full-format listing.</em></p>
<p>如果看到sshd和ssh-agent两个进程，则成功。</p>
<h2 id="2-__u5B89_u88C5hadoop"><a href="#2-__u5B89_u88C5hadoop" class="headerlink" title="2. 安装hadoop"></a>2. 安装hadoop</h2><p>1.创建用户组hadoop以及用户hadoopu：          </p>
<pre><code>sudo addgroup hadoop 

sudo adduser --ingroup hadoop hadoopu
</code></pre><p>2.将下载的hadoop.tar.gz拷入hadoopu家目录下：</p>
<pre><code>cp /downloads/hadoop-1.0.4-bin.tar.gz /home/hadoopu/
</code></pre><p>3.解压hadoop包</p>
<pre><code>tar xzf hadoop-1.0.4-bin.tar.gz
</code></pre><p>4.进入hadoop-env.sh所在目录（hadoop-1.0.4/conf/），对该文件进行如下内容的修改：</p>
<pre><code>export JAVA_HOME=/usr/lib/jvm/java-6-openjdk-amd64
</code></pre><p>（/usr/lib/jvm/java-6-openjdk-amd64为jdk安装目录）</p>
<p>5.为了方便更改环境变量，将环境变量的设置写入/etc/profile：</p>
<pre><code>export JAVA_HOME=/usr/lib/jvm/java-6-openjdk-amd64 
export HADOOP_HOME=/home/hadoopu/hadoop-1.0.4 
export PATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin 
export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/htmlconverter.jar:$JAVA_HOME/lib/jconsole.jar:$JAVA_HOME/lib/sa-jdi.jar
</code></pre><p>执行该文件，使配置生效：</p>
<pre><code>source /etc/profile
</code></pre><blockquote><p>The /etc/profile file contains system wide environment stuff and startup programs.</p>
<p>The /etc/profile file is used to set system wide environmental variables on users shells. The variables are sometimes the same ones that are in the .bash_profile, however this file is used to set an initial PATH or PS1 for all shell users of the system.</p>
</blockquote>
<p>ok. 至此安装完成了</p>
<h1 id="2-__u5728_u96C6_u7FA4_u4E0A_u8FD0_u884Cmapreduce_u7A0B_u5E8F"><a href="#2-__u5728_u96C6_u7FA4_u4E0A_u8FD0_u884Cmapreduce_u7A0B_u5E8F" class="headerlink" title="2. 在集群上运行mapreduce程序"></a>2. 在集群上运行mapreduce程序</h1><h2 id="1-__u5C06Master_u7684pubkey_u62F7_u8D1D_u5230slave_u4E0A"><a href="#1-__u5C06Master_u7684pubkey_u62F7_u8D1D_u5230slave_u4E0A" class="headerlink" title="1. 将Master的pubkey拷贝到slave上"></a>1. 将Master的pubkey拷贝到slave上</h2><p>如果没有生产过ssh-key:</p>
<pre><code>ssh-keygen -t rsa -b 4096 -C &quot;mypc&quot;
</code></pre><p>放到目标上机器，一步到位最方便的ssh-copy-id：</p>
<pre><code>ssh-copy-id username@hostname
</code></pre><h2 id="2-__u4E3Aproject_u521B_u5EFA_u6587_u4EF6_u5939_u53CAconf_u6587_u4EF6"><a href="#2-__u4E3Aproject_u521B_u5EFA_u6587_u4EF6_u5939_u53CAconf_u6587_u4EF6" class="headerlink" title="2. 为project创建文件夹及conf文件"></a>2. 为project创建文件夹及conf文件</h2><p>在/home/hadoopu下：  </p>
<pre><code>mkdir HadoopClusterTest  

cd HadoopClusterTest/ 

mkdir conf  

cp HADOOP_HOME/conf/* conf
</code></pre><p>编辑相关配置文件：  </p>
<p>core-site.xml: 用于配置Common组件的属性<br>hdfs-site.xml: 用于配置HDFS的属性<br>mapred-site.xml: 用于配置MapReduce的属性<br>masters 指定master节点 slaves 指定slave节点</p>
<p>这个project <a href="https://github.com/potatoker/hadoop-nbCliassifier/tree/master/conf" target="_blank" rel="external">conf</a>只是对老师的示例conf做了非常简单的改变.<br>这个conf包括的只是最基本的一些配置，许多属性的设置都是默认值，今后需要更好的理解hadoop才可以完善各项配置。</p>
<p>另：可以自己添加属性。</p>
<figure class="highlight pf"><figcaption><span>core-site.xml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&lt;property&gt;</span></span><br><span class="line"><span class="variable">&lt;name&gt;</span>token_in_class_num_path<span class="variable">&lt;/name&gt;</span></span><br><span class="line"><span class="variable">&lt;value&gt;</span>hdfs://localhost/<span class="keyword">user</span>/hadoopu/classfnum/part-r-<span class="number">00000</span><span class="variable">&lt;/value&gt;</span></span><br><span class="line"><span class="variable">&lt;/property&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后在程序中，conf读入了配置文件的键值对，包括自己添加的.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Configuration conf;  </span><br><span class="line"><span class="keyword">private</span> FileSystem fs;    </span><br><span class="line">conf = context.getConfiguration();  </span><br><span class="line">fs = FileSystem.get(<span class="keyword">new</span> URI(<span class="string">"hdfs:///"</span>), conf);  </span><br><span class="line">Path token_in_class_num_path = <span class="keyword">new</span>  Path(conf.get(TOKEN_IN_CLASS_NUM_PATH));</span><br></pre></td></tr></table></figure></p>
<p>在project的应用是训练结果作为sequencefile放在hdfs中，分类时在程序中通过conf获取该训练结果文件所在路径，从而将文件内容读入程序.</p>
<p><strong>这里我想使用自己目录下的配置文件，需要修改环境变量:</strong></p>
<pre><code>export HADOOP_CONF_DIR=~/HadoopClusterTest/conf 
</code></pre><p>这一步十分关键，好几次自己忽略了，因而产生问题。</p>
<h2 id="3-_u542F_u52A8hadoop"><a href="#3-_u542F_u52A8hadoop" class="headerlink" title="3.启动hadoop"></a>3.启动hadoop</h2><h3 id="1-_u683C_u5F0F_u5316hdfs_3A"><a href="#1-_u683C_u5F0F_u5316hdfs_3A" class="headerlink" title="1.格式化hdfs:"></a>1.格式化hdfs:</h3><pre><code>hadoop fs namenode -format
</code></pre><h3 id="2-__u5728master_u4E0A_u542F_u52A8hadoop_u5B88_u62A4_u8FDB_u7A0B"><a href="#2-__u5728master_u4E0A_u542F_u52A8hadoop_u5B88_u62A4_u8FDB_u7A0B" class="headerlink" title="2. 在master上启动hadoop守护进程"></a>2. 在master上启动hadoop守护进程</h3><pre><code>start-all.sh
</code></pre><h3 id="3-_u4F7F_u7528jps_u67E5_u770B_u5168_u90E8hadoop_u76F8_u5173_u8FDB_u7A0B"><a href="#3-_u4F7F_u7528jps_u67E5_u770B_u5168_u90E8hadoop_u76F8_u5173_u8FDB_u7A0B" class="headerlink" title="3.使用jps查看全部hadoop相关进程"></a>3.使用jps查看全部hadoop相关进程</h3><p>在master上应该有一下三个进程:</p>
<pre><code>JobTracker
NameNode
SecondaryNameNode
</code></pre><p>在slave上应该有以下两个进程：</p>
<pre><code>TaskTracker
DataNode
</code></pre><p>并且可以看到core-site中的hadoop.tmp.dir属性指定的tmpdir被创建.</p>
<h3 id="4-_Hadoop_webUI_u8BBF_u95EE"><a href="#4-_Hadoop_webUI_u8BBF_u95EE" class="headerlink" title="4. Hadoop webUI访问"></a>4. Hadoop webUI访问</h3><ol>
<li><p>查看集群状态：<a href="http://masterIP:50070" target="_blank" rel="external">http://masterIP:50070</a></p>
</li>
<li><p>查看hdfs：<a href="http://mastetIP:50030" target="_blank" rel="external">http://mastetIP:50030</a></p>
</li>
</ol>
<p>各类log都可以通过webUI访问，集群工作时通过webUI进行监控也十分方便</p>
<h3 id="5-__u505C_u6B62hadoop_u5B88_u62A4_u8FDB_u7A0B"><a href="#5-__u505C_u6B62hadoop_u5B88_u62A4_u8FDB_u7A0B" class="headerlink" title="5. 停止hadoop守护进程"></a>5. 停止hadoop守护进程</h3><pre><code>stop-all.sh
</code></pre><p>这里遇到过一个问题是，基于上述的配置文件，当我二次格式化hdfs的时候失败，并且发现namenode启动不了了。<br>    查看log，二次格式化失败的原因似乎是因为当前hdfs在安全模式下,在安全模式下也无法删除hdfs上的文件。要解除安全模式:</p>
<pre><code>hadoop dfsadmin -safemode leave
</code></pre><p>重开：</p>
<pre><code>hadoop dfsadmin -safemode get
</code></pre><p>其实一般都不需要重新格式化hdfs…要重启的话只需stop.all.sh和start-all.sh切换即可。</p>
<h2 id="4-__u6D4B_u8BD5_u96C6_u7FA4"><a href="#4-__u6D4B_u8BD5_u96C6_u7FA4" class="headerlink" title="4. 测试集群"></a>4. 测试集群</h2><p>当然，如果做测试，可以直接使用从HADOOP_HOME中拷贝过来的conf，几乎不用做修改，只用修改slaves和master文件增加ip即可.<br>现测试运行自带的程序wordCount</p>
<h3 id="1-__u65B0_u5EFA_u6D4B_u8BD5_u6587_u672C_u6587_u4EF6test-txt_uFF0C_u6DFB_u52A0_u4EFB_u610F_u6587_u672C"><a href="#1-__u65B0_u5EFA_u6D4B_u8BD5_u6587_u672C_u6587_u4EF6test-txt_uFF0C_u6DFB_u52A0_u4EFB_u610F_u6587_u672C" class="headerlink" title="1. 新建测试文本文件test.txt，添加任意文本"></a>1. 新建测试文本文件test.txt，添加任意文本</h3><h3 id="2-__u628A_u8BE5_u6587_u4EF6_u653E_u5165hdfs_u4E2D"><a href="#2-__u628A_u8BE5_u6587_u4EF6_u653E_u5165hdfs_u4E2D" class="headerlink" title="2. 把该文件放入hdfs中"></a>2. 把该文件放入hdfs中</h3><p>在hdfs中创建目录input:</p>
<pre><code>hadoop fs -mkdir /user/hadoopu/input  
</code></pre><p>将本地文件系统的中的test.txt放入上述hdfs的input目录下：  </p>
<pre><code>hadoop fs -put /home/hadoopu/test.txt /user/hadoopu/input/
</code></pre><p>通过 -ls 参数可以查看：</p>
<pre><code>haddoop fs -ls /user/hadoopu/input
</code></pre><h3 id="3-_u8FD0_u884C_u6D4B_u8BD5_u7A0B_u5E8F"><a href="#3-_u8FD0_u884C_u6D4B_u8BD5_u7A0B_u5E8F" class="headerlink" title="3.运行测试程序"></a>3.运行测试程序</h3><p>切换到之前的HadoopCluster目录下运行:</p>
<pre><code>hadoop jar $HADOOP_HOME/hadoop-examples-1.0.4.jar wordcount /user/hadoopu/input/test/txt /user/hadoopu/output
</code></pre><p>后一个目录代表输出文件夹，如果运行前存在的话会报错。</p>
<p>wordcount表示要运行这个jar包中的主类wordcount，它应该是一个完全限定名，更多情况下形如pagege1.pakage2.wordcount</p>
<h2 id="conclusion"><a href="#conclusion" class="headerlink" title="conclusion"></a>conclusion</h2><p>其实做这个实验的时候真的暴露了很多问题，自己对真正hadoop的运行过程及原理还没有摸到皮毛，感觉这个只能算是个人note….whatever， no one else will see it.</p>
<p>马上要接下hz的活了，并行这一块的工程能力的恶补要提上日程了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本来想要多花时间把这份作业尽量做好，结果懒癌晚期让我在deadline前两天才开始做。。。</p>
<p>其实现在自己连门都没入，不过近段时间恐怕都没有时间继续学习hadoop了，所以下次做实验最好能尽快回忆起已学的记下这篇流水账，。<br>此外发现自己对linux仍然各种不熟，，，形成了这篇本质流水账</p>
<p>project基于hadoop 1.0.4. 属于很早的版本</p>]]>
    
    </summary>
    
      <category term="hadoop" scheme="http://potatoker.github.io/tags/hadoop/"/>
    
      <category term="linux" scheme="http://potatoker.github.io/tags/linux/"/>
    
      <category term="parellel" scheme="http://potatoker.github.io/categories/parellel/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[akka-on-android]]></title>
    <link href="http://potatoker.github.io/2015/12/24/akka-on-android/"/>
    <id>http://potatoker.github.io/2015/12/24/akka-on-android/</id>
    <published>2015-12-24T02:10:33.000Z</published>
    <updated>2015-12-24T22:27:49.802Z</updated>
    <content type="html"><![CDATA[<p>scala环境没问题了，接下来就是加入akka。<br>其实真正麻烦的在akka的库调用上。。特别是proguard rule的debug简直是摸瞎。(ಥ _ ಥ)</p>
<a id="more"></a>
<p>正常来说：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span> <span class="string">"org.scala-lang:scala-library:2.11.7"</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">"com.android.support:multidex:1.0.1"</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.typesafe.akka:akka-actor_2.11:2.3.9'</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.typesafe.akka:akka-remote_2.11:2.3.9'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把akka的库依赖加入gradle文件，完事。但事实是问题接二连三</p>
<h2 id="1-_Gradle_duplicate_file_exception"><a href="#1-_Gradle_duplicate_file_exception" class="headerlink" title="1. Gradle duplicate file exception"></a>1. Gradle duplicate file exception</h2><p>当时，具体的错误信息找不到了，不过我的解决方案是在这个<a href="https://code.google.com/p/android/issues/detail?id=61573" target="_blank" rel="external">issue</a>下面找到的,如他描述的，在两个jar中包含相同的文件。但师兄用sbt构建过相同的程序。为什么gradle会出现不得而知。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">error: duplicate files during packaging of APK .../basic/build/apk/basic-debug-unaligned<span class="class">.apk</span></span><br><span class="line">	Path <span class="keyword">in</span> archive: about<span class="class">.html</span></span><br><span class="line">	Origin <span class="number">1</span>: ...filestore/org<span class="class">.eclipse</span><span class="class">.jetty</span>/jetty-servlet/<span class="number">8.1</span>.<span class="number">8</span>.v20121106/jar/<span class="number">285</span>ea47746e9ab988a8291ea9fd6545b537e0ce9/jetty-servlet-<span class="number">8.1</span>.<span class="number">8</span><span class="class">.v20121106</span><span class="class">.jar</span></span><br><span class="line">	Origin <span class="number">2</span>: ...filestore/org<span class="class">.eclipse</span><span class="class">.jetty</span>/jetty-client/<span class="number">8.1</span>.<span class="number">8</span>.v20121106/jar/f194a5a07ada9dab48e226c4e8152d120ce1e76f/jetty-client-<span class="number">8.1</span>.<span class="number">8</span><span class="class">.v20121106</span><span class="class">.jar</span></span><br></pre></td></tr></table></figure>
<p>我的库依赖为</p>
<pre><code>&apos;com.typesafe.akka:akka-actor_2.11:2.3.9&apos;
&apos;com.typesafe.akka:akka-remote_2.11:2.3.9&apos;
</code></pre><p>类似于上述代码中的错误信息，console提示我这两个jar，包含了本地path:</p>
<pre><code>C:\Users\Ray\.ivy2\cache\com.typesafe.akka\....
</code></pre><p>然后我来到这个位置，找到上述两个jar，打开后发现确实，其中包含同名文件：reference.conf，可以判断是这个原因gradle显示duplicate file error， 然而我发现这两个文件内容并不相同。我猜想是因为同名的原因，因此我将这两个conf分别加了相应的前缀。然而仍然不可行，错误记录找不到了。但我觉得确实可能有问题，因为修改文件名应该谨慎，其他地方可能有引用。如此寻找其他的方法。</p>
<p>最终，根据上文中的issue，试出来的办法是：</p>
<ol>
<li><p>merge这两份conf文件，因为其实发现这两个配置文件确实仍然有重复的部分，而且都是类json的键值对数据组织方式，所以把其中一份所有的内容加到另一份中，并保证不重复。</p>
</li>
<li><p>在gradle中去重。<br>因为实际上我采取的策略是只使用一份conf文件，但这份conf包含之前两份的功能，但是我并没有删除任何一份，我把这份merge 过的文件加入到上述两个jar中，这样，我就成了两份<strong>真正</strong>相同文件的去重问题了。</p>
</li>
</ol>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">android</span> &#123;  </span><br><span class="line">    <span class="title">packagingOptions</span> &#123;    </span><br><span class="line">        <span class="title">pickFirst</span> <span class="string">'reference.conf'</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>于是就这样解决了这一问题。也是google了好久，当时看到这个<a href="(https://code.google.com/p/android/issues/detail?id=61573">issue</a>的时候，楼已经盖得老高了，很多描述也不是很详细， 看了好久才总结出了这个解决办法。<br>其实这个问题解决了之后，我的akka就这样真的在我的小米上跑起来了。成功使一台android 5.0设备作为一台slave完成了一项并行处理任务。</p>
<p>本该一切就这样结束了(ಥ _ ಥ)。</p>
<h2 id="2-_LinearAlloc_5MB_capacity"><a href="#2-_LinearAlloc_5MB_capacity" class="headerlink" title="2. LinearAlloc 5MB capacity"></a>2. LinearAlloc 5MB capacity</h2><p>然而，并没有什么*用，因为某原因，我仍然需要在使得该程序在g5(api 10,version 2.3.7)上跑起来。</p>
<p>果然，傲娇的g5没有跑通：</p>
<p>我出现了类似这个<a href="http://stackoverflow.com/questions/23438213/package-has-mismatched-uid-10124-on-disk-10134-in-settings" target="_blank" rel="external">SO</a>上的问题：</p>
<pre><code>Package has mismatched uid: 10124 on disk, 10134 in settings

 E/dalvikvm( 7815): LinearAlloc exceeded capacity (5242880), last=1092
</code></pre><blockquote><p>Solutions:</p>
<p>Proguard: Proguard removes unreferenced classes/methods from your app. Thus your app’s dex file size decreases. (I’ve solved my problem with proguard)  </p>
<p>Multiple Dex Files: Split your app to multiple dex files. <a href="https://www.facebook.com/notes/facebook-engineering/under-the-hood-dalvik-patch-for-facebook-for-android/10151345597798920" target="_blank" rel="external">Facebook</a> has a solution for this. Also read this <a href="http://android-developers.blogspot.se/2011/07/custom-class-loading-in-dalvik.html" target="_blank" rel="external">link</a> for managing multiple dex files.</p>
</blockquote>
<p>答案中说可以使用Multidex解决，我在想我已经按照google文档multidex方法启动了multidex了啊？但此时我们使用的g5，要重新来看待multidex以及它在低端机上可能产生的问题，再来看<a href="http://developer.android.com/tools/building/multidex.html" target="_blank" rel="external">Building Apps with Over 65K Methods</a>的multidex方法描述：<br><blockquote><p>Applications that use multidex may not start on devices that run versions of the platform earlier than Android 4.0 (API level 14) due to a Dalvik linearAlloc bug (Issue 22586). If you are targeting API levels earlier than 14, make sure to perform testing with these versions of the platform as your application can have issues at startup or when particular groups of classes are loaded. Code shrinking can reduce or possibly eliminate these potential issues.  </p>
<p>Applications using a multidex configuration that make very large memory allocation requests may crash during run time due to a Dalvik linearAlloc limit (Issue 78035). The allocation limit was increased in Android 4.0 (API level 14), but apps may still run into this limit on Android versions prior to Android 5.0 (API level 21).</p>
</blockquote></p>
<p><strong>So, the problem is Allocation Limit In old android version!</strong>，android5.0提升了很多，而g5的2.3version很小。因此解释虽然使用multidex可以在小米上跑成功而g5则不可以。</p>
<p>这个问题其实是许多需要大型依赖库app运行在某些低端机上会遇到的继method limit之后的第二个问题<a href="https://code.google.com/p/android/issues/detail?id=22586" target="_blank" rel="external">Issue 22586</a>,后文中简称为allocation limit。想要加入类似akka的大型库依赖，就必须解决这两个问题，关于这两个问题，<a href="https://ingramchen.io/blog/2014/09/prevention-of-android-dex-64k-method-size-limit.html" target="_blank" rel="external">这篇文章</a>有很好的解释分析</p>
<blockquote><p>安裝 apk 時，如果出現上面提到的兩種錯誤，你通常會看到錯誤訊息有 INSTALL_FAILED_DEXOPT 這行。dexopt 是 dex optimization 的意思，這一步驟會發生在安裝完 apk 之後，它會檢驗 .dex 裡面的指令集是不是合法，也會驗 method 的上限數。超過上限的話，app 還沒啟動就被這一步擋下，直接噴錯。dexopt 也會試著將所有 class/method 都讀進 VM 驗證，這自然會運用到 LinearAlloc buffer。如果 buffer 不夠也是直接噴了。所以程式太大的話，通通會死在 dexopt 這過程裡。</p>
<footer><strong>預防 Android Dex 64k Method Size Limit</strong><cite><a href="https://ingramchen.io/blog/2014/09/prevention-of-android-dex-64k-method-size-limit.html" target="_blank" rel="external">ingramchen.io/blog/2014/09/prevention-of-android-dex-64k-method-size-limit.html</a></cite></footer></blockquote>
<blockquote><p>apk是一个zip压缩包，dalvik每次加载apk都要从中解压出class.dex文件，加载过程还涉及到dex的classes需要的杂七杂八的依赖库的加载，真耗时间。于是Android决定优化一下这个问题，在app安装到手机之后，系统运行dexopt程序对dex进行优化，将dex的依赖库文件和一些辅助数据打包成odex文件。存放在cache/dalvik_cache目录下。保存格式为apk路径 @ apk名 @ classes.dex。这样以空间换时间大大缩短读取/加载dex文件的过程。<br>那刚才那个bug是啥问题呢，原来dexopt程序的dalvik分配一块内存来统计你的app的dex里面的classes的信息，由于classes太多方法太多超过这个linearAlloc 的限制</p>
<footer><strong>其实你不知道MultiDex到底有多坑</strong><cite><a href="http://zongwu233.github.io/the-touble-of-multidex/" target="_blank" rel="external">zongwu233.github.io/the-touble-of-multidex</a></cite></footer></blockquote>
<p>虽然使用了multidex,产生了多个dex,然而可能某个dex仍然会过大，而为了载入这个dex的class信息分配的内存有一个最大的限制。<a href="https://www.facebook.com/notes/facebook-engineering/under-the-hood-dalvik-patch-for-facebook-for-android/10151345597798920" target="_blank" rel="external">Under the Hood: Dalvik patch for Facebook for Android</a>这篇文章被引用，被解释说fb写了方案覆盖了这个容量限制，解决该问题。</p>
<p>民间出高人，除了fb的方法,还有探究这一问题的文章<a href="http://www.birbit.com/how-to-solve-linearalloc-problem/" target="_blank" rel="external">How to Solve LinearAlloc Problem</a>，以及后来我搜中文找到的<a href="http://zongwu233.github.io/the-touble-of-multidex/" target="_blank" rel="external">其实你不知道MultiDex到底有多坑</a>，总结了许多,这标题真的不是为我量身定做的吗(ಥ _ ಥ)，这篇文章解释清楚了我对于method limit 和 linearAlloc的另一些困惑。同时也在解决问题的过程中挖的非常深，包括其中的几篇引用。。。ok,ok, let’s have a break，[姚明脸]。</p>
<h3 id="Let_u2019s_try_Proguard_21"><a href="#Let_u2019s_try_Proguard_21" class="headerlink" title="Let’s try Proguard!"></a>Let’s try Proguard!</h3><p>也就是说，虽然我之前使用multidex来解决的scala库的methods limit问题，现在我重新使用proguard来解决所有因为依赖库(包括scala、akka)太大引起的问题。<strong>这里的问题包括methods limit和allocation limit</strong></p>
<p>上面SO答主说明的他采取的并最终解决了linearAlloc问题的方法，我之所以觉得他更有可能解决这个问题是因为<br>我觉得proguard方法的原理是最直接解决g5上跑较大规模依赖库app的问题，因为它十分具体的减少了构建过程的class的量，这样有效的避免了DEX 64K Methods Limit,同时也使得LinearAlloc Problem不需要考虑，事实上，在使用Multidex解决DEX 64K Methods Limit的时候，官方文档甚至提出在某些低端机上要使用proguard做配合。然而每个不同的依赖都有不同的rules，我必须找到这样一份akka rules。</p>
<p>总体的思路是：</p>
<ol>
<li>在gradle中说明启用proguard及其相关rule。</li>
<li>在网上查找akka库是否已经有现成的proguard rule文件，有则使用。</li>
<li>别人的rule并不一定完全适用，build的时候会出现class not found的问题</li>
<li>根据错误提示，增加keep 规则</li>
<li>重复3,4直至build和run的时候都没有classNotFound的问题</li>
</ol>
<p>这个东西当我第一次看到他的<a href="https://stuff.mit.edu/afs/sipb/project/android/sdk/android-sdk-linux/tools/proguard/docs/index.html#manual/introduction.html" target="_blank" rel="external">文档</a>的时候，就方了，这种朴素的markdown风格加上瀑布一般的排版。。。看不下去。。。总之原理基本上是，根据控制台输出的错误信息，一般是，方法或者类丢失，说明proguard丢弃了这个方法或类，那么在rule文件里把有完全限定名的类使用keep语句手动保留，就可以了。比较典型的有下面两种：  </p>
<pre><code>如果Build过程提示classNotFound或者methodNotFound就直接keep 
</code></pre><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-keep class akka.actor.LocalActorRefProvider<span class="variable">$Guardian</span>&#123;</span><br><span class="line">  *;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果告诉你类似<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.RuntimeException: Unable to <span class="operator"><span class="keyword">start</span> activity ComponentInfo&#123;com.myapp/com.myapp.MyActivity&#125;: <span class="keyword">java</span>.lang.NoSuchMethodException: &lt;init&gt; [<span class="keyword">interface</span> com.typesafe.config.Config, <span class="keyword">interface</span> akka.<span class="keyword">event</span>.LoggingAdapter, <span class="keyword">interface</span> <span class="keyword">java</span>.util.<span class="keyword">concurrent</span>.ThreadFactory]</span></span><br></pre></td></tr></table></figure></p>
<p>则用：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">keepclasseswithmembers <span class="class"><span class="keyword">class</span> * &#123;</span></span><br><span class="line"></span>    public &lt;init&gt;(com.typesafe.config.Config, akka.event.LoggingAdapter, java.util.concurrent.ThreadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p>
<p>这两招屡试不爽。。虽然proguard还有许多其他keep方式。。。但实在不想去看瀑布了。。</p>
<p>在这个过程中数度想要放弃<br><strong>BUT</strong>确实到最后没有classNotFound的问题了，build也成功了，然而新问题是：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">11</span>:<span class="number">27</span>:<span class="number">42.149</span>] [WorkerSystem-akka.remote.default-remote-dispatcher-<span class="number">6</span>] [akka.tcp:<span class="regexp">//</span>WorkerSystem<span class="variable">@192</span>.<span class="number">168.1</span>.<span class="number">108</span>:<span class="number">2555</span>/<span class="keyword">system</span>/endpointManager/reliableEndpointWriter-akka.tcp<span class="variable">%3A</span><span class="variable">%2F</span><span class="variable">%2FParallelHOSVD</span><span class="variable">%40192</span>.<span class="number">168.1</span>.<span class="number">102</span><span class="variable">%3A2552</span>-<span class="number">0</span>] Association with remote <span class="keyword">system</span> [akka.tcp:<span class="regexp">//</span>ParallelHOSVD<span class="variable">@192</span>.<span class="number">168.1</span>.<span class="number">102</span>:<span class="number">2552</span>] has failed, address is now gated <span class="keyword">for</span> [<span class="number">5000</span>] ms. Reason is: [exception during creation].</span><br></pre></td></tr></table></figure>
<p>然后我用小米同样试着跑了一下，发现一样的问题，所以是我前面的build过程仍然有问题。然而现在已知的错误信息只有这个，并且似乎只是简单地在阐述连接失败，并没有为何失败的信息。从这个节点已经查不下去了。</p>
<p>事实上，网上确实已有不少akka proguard，<a href="https://github.com/sbt/sbt-proguard/blob/master/src/sbt-test/proguard/akka/project/SampleBuild.scala" target="_blank" rel="external">sbt-proguard</a>，<a href="https://groups.google.com/forum/#!topic/scala-on-android/JwMQCtC2zCs" target="_blank" rel="external">Akka, Android, Proguard</a>,甚至已有和我同样在这样以身试坑的人在：<a href="http://spin.atomicobject.com/2013/06/20/akka-scala-on-android/" target="_blank" rel="external">Getting Scala with Akka Actors Working on Android</a>.</p>
<blockquote><p>Once the code was running, I would wait for it to crash with a runtime exception, which would tell me what class was missing.<br>I could then update my ProGuard config, rinse, and repeat.</p>
</blockquote>   
<h3 id="proguard_conclusion"><a href="#proguard_conclusion" class="headerlink" title="proguard conclusion"></a>proguard conclusion</h3><p>该保留哪些方法哪些class靠人工写一份没有漏洞的rule太难，关于第三方库proguard rule看到过这样的阐述:</p>
<blockquote><p>Many problems with ProGuard stem from the inclusion of third-party libraries in your project.<br>the first step in avoiding such errors is to consult the documentation of each third-party library and follow any instructions for deployment with ProGuard.<br>If the documentation mentions nothing about ProGuard, but the library is open source, then there is no point to obfuscating its code from a security standpoint anyway.</p>
<footer><strong>A Conservative Guide to ProGuard for Android</strong><cite><a href="http://omgitsmgp.com/2013/09/09/a-conservative-guide-to-proguard-for-android/" target="_blank" rel="external">omgitsmgp.com/2013/09/09/a-conservative-guide-to-proguard-for-android</a></cite></footer></blockquote>
<h2 id="Still_using_multidex"><a href="#Still_using_multidex" class="headerlink" title="Still using multidex"></a>Still using multidex</h2><p>如果使用Multidex方法，则要解决<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Package has mismatched uid: <span class="number">10124</span> <span class="function_start"><span class="keyword">on</span></span> disk, <span class="number">10134</span> <span class="keyword">in</span> settings   </span><br><span class="line">E/dalvikvm( <span class="number">7815</span>): LinearAlloc exceeded capacity (<span class="number">5242880</span>), <span class="keyword">last</span>=<span class="number">1092</span></span><br></pre></td></tr></table></figure></p>
<p>根据之前的总结其实是Android早期版本的Dalvik linearAlloc bug。。其实当我读完<a href="http://zongwu233.github.io/the-touble-of-multidex/" target="_blank" rel="external">其实你不知道MultiDex到底有多坑</a>。远不止这个bug需要解决。。。这个坑。。等我吃点好的再跳(ಥ _ ಥ).</p>
<h2 id="conclusion"><a href="#conclusion" class="headerlink" title="conclusion"></a>conclusion</h2><p>所以其实这整个过程，如果不看g5，已经做到了使用scala写android程序，以及在Android5.0设备上使用akka，使移动设备成为一个并行系统的slave进行工作。</p>
<p>至于g5的结论就是使用proguard可以解决scala库依赖的问题，然而当我再添加akka时，proguard我目前只会采取摸瞎的方式写rules，操作的不确定性极大，如果不使用proguard,使用multidex解决<code>scala&amp;akka-actor&amp;akka-remote</code>这种规模的依赖库依赖问题仍有<strong>Dalvik linearAlloc bug</strong>待解决。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>scala环境没问题了，接下来就是加入akka。<br>其实真正麻烦的在akka的库调用上。。特别是proguard rule的debug简直是摸瞎。(ಥ _ ಥ)</p>]]>
    
    </summary>
    
      <category term="akka" scheme="http://potatoker.github.io/tags/akka/"/>
    
      <category term="android" scheme="http://potatoker.github.io/tags/android/"/>
    
      <category term="build" scheme="http://potatoker.github.io/tags/build/"/>
    
      <category term="parallel" scheme="http://potatoker.github.io/tags/parallel/"/>
    
      <category term="android" scheme="http://potatoker.github.io/categories/android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[scala on android]]></title>
    <link href="http://potatoker.github.io/2015/12/23/scala-on-android/"/>
    <id>http://potatoker.github.io/2015/12/23/scala-on-android/</id>
    <published>2015-12-23T07:11:30.000Z</published>
    <updated>2016-08-17T04:30:12.323Z</updated>
    <content type="html"><![CDATA[<p>今天大概要宣布第一条路走不通了。</p>
<p>感觉还是有必要把这条路重新理一下。。。毕竟并不是什么效果都没有看到。</p>
<p>任务：在安卓手机上实现akka remote，我也不知道做这件事情到底有什么意义= =</p>
<p>现有条件： </p>
<ol>
<li>一个需要akka跑的scala分布式程序。</li>
<li>丧心病狂的来了，由于某种更加扭曲的实验方式的限制，最终实验必须要在一台g5上跑起来。</li>
</ol>
<a id="more"></a>
<h1 id="scala_on_android"><a href="#scala_on_android" class="headerlink" title="scala on android"></a>scala on android</h1><p> 经过搜索之后，发现在安卓平台上跑scala并不是什么新鲜事了，scala作为一门基于java虚拟机的语言，同样第一步需要预编译成class文件，然后打包成apk安装到android上，原理上是完全没有问题的。</p>
<p>不过当时遇到的问题是，一般scala使用的build tool 是sbt，而我目前使用的IDE android studio使用的是gradle. 这样记得当时google出来的scala on android的一些插件或者套路基本根据这两种build tool来的。我也不知道该使用哪一种，因为实际上两种我都并没有很了解，似乎走了不少弯路。  </p>
<p>不过最终，让我跑通的是：<a href="https://github.com/saturday06/gradle-android-scala-plugin" target="_blank" rel="external">基于gradle的</a>，毕竟这是android studio自带的build tool, 配置起来可能会方便一点。</p>
<p>这里遇到一个问题是<a href="https://developer.android.com/tools/building/multidex.html" target="_blank" rel="external">DEX 64K Methods Limit</a>.当依赖的库太多的时候(这个scala语言库本身还是比较大)，毕竟这些Jar包都要被一起build成一个dex文件，而默认一个apk只包含一个dex文件。 android的build机制对这样的一个库的容量有所限制.：</p>
<blockquote><p>As the Android platform has continued to grow, so has the size of Android apps. When your application and the libraries it references reach a certain size, you encounter build errors that indicate your app has reached a limit of the Android app build architecture. Earlier versions of the build system report this error as follows:</p>
<pre><code>Conversion to Dalvik format failed:
Unable to execute dex: method ID not in [0, 0xffff]: 65536
</code></pre><p>More recent versions of the Android build system display a different error, which is an indication of the same problem:</p>
<pre><code>trouble writing output:
Too many field references: 131000; max is 65536.
You may try using --multi-dex option.
</code></pre></blockquote>
<p>其实这个问题在解决scala库依赖的时候根本不需要我操心。。因为我只用在作者已经配置好的<a href="https://github.com/saturday06/gradle-android-scala-plugin/tree/master/sample/simple" target="_blank" rel="external">sample</a>上继续写程序就可以了。</p>
<h3 id="1-_use_proguard"><a href="#1-_use_proguard" class="headerlink" title="1. use proguard."></a>1. use proguard.</h3><p>android devloper上有简单地概念介绍：</p>
<blockquote><p>The ProGuard tool shrinks, optimizes, and obfuscates your code by removing unused code and renaming classes, fields, and methods with semantically obscure names. The result is a smaller sized .apk file that is more difficult to reverse engineer.</p>
<footer><strong>ProGuard</strong><cite><a href="http://developer.android.com/tools/help/proguard.html" target="_blank" rel="external">developer.android.com/tools/help/proguard.html</a></cite></footer></blockquote>
<p>这东西有两个作用，一个是减小apk的大小，一个是对方法名进行混淆。我需要用到他的第一个作用，思路就是引用的库中，很多方法其实根本用不到，所以proguard就会帮助build tool把引用到的那一部分加入编译，这样就不会使dex文件过大。那么他是怎么判断哪些方法该被加入编译，哪些是没用的呢，这东西还没有那么智能。。需要一份rules来规定哪些方法和类是需要保存的，虽然sdk tool自带一份默认的rules，但是！一般情况还是需要debug一下，然后手动修改rules文件。如果是第三方的jar包，那就更没得跑了。</p>
<p>其实在使用scala lib的时候并不需要这一步，因为之前提到过，直接使用作者已经配置好的<a href="https://github.com/saturday06/gradle-android-scala-plugin/tree/master/sample/simple" target="_blank" rel="external">sample</a>就可以了，不过这个sample使用的是第二种方法。但是如果想要使用progurad来解决这个问题也可以在网上找到现成的scala库的<a href="https://github.com/pocorall/hello-scaloid-gradle/blob/master/proguard-rules.txt" target="_blank" rel="external">proguard rule</a>,这个方法我也使用过，也可以成功跑通scala.</p>
<p>scala这一块已经解决，然而。。akka似乎并没有提供这样一份东西。。详细的内容在后一篇。</p>
<h3 id="2-_Use_MultiDex"><a href="#2-_Use_MultiDex" class="headerlink" title="2. Use MultiDex"></a>2. Use MultiDex</h3><p>事实上我使用的作者的sample 并没有使用proguard方法，而是使用 multidex。<br>解决思路就是，以前一个apk只有一个dex包，dex又有大小限制，那么我就吧class分成多个dex打包，使用不同dex中的class的时候就动态加载。这样就不会超过这个限制。</p>
<p>官方解释：<br><blockquote><p>Versions of the platform prior to Android 5.0 use the Dalvik runtime for executing app code. By default, Dalvik limits apps to a single classes.dex bytecode file per APK. In order to get around this limitation, you can use the multidex support library, which becomes part of the primary DEX file of your app and then manages access to the additional DEX files and the code they contain. </p>
<p>Android 5.0 and higher uses a runtime called ART which natively supports loading multiple dex files from application APK files.</p>
</blockquote></p>
<p>其实主要是在gradle的build文件中添加multidex方法的依赖库，然后修改一些关联的配置<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">  <span class="keyword">compile</span> <span class="string">'com.android.support:multidex:1.0.0'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p>
<p>详细的内容太仍然在<a href="https://developer.android.com/tools/building/multidex.html#mdex-gradle" target="_blank" rel="external">Configuring Your App for Multidex with Gradle</a> 。</p>
<p><strong>这里有非常重要的一点是multidex方法不能直接适用于低端机，我使用的是android 5.0device，在akka-on-andorid中我使用了multidex试图解决大型库依赖的问题，但会产生另外的问题。但是Android 2.3.7使用proguard之后是可以跑这个scala库的。</strong></p>
<h3 id="in_the_end"><a href="#in_the_end" class="headerlink" title="in the end"></a>in the end</h3><p>总结一下，在android上使用scala:</p>
<ol>
<li><p>根据IDE下载scala语言的parse插件，我在android studio中使用的是<a href="http://www.jetbrains.net/confluence/display/SCA/Scala+Plugin+for+IntelliJ+IDEA" target="_blank" rel="external">这款</a>。这样IDE可以识别scala.</p>
</li>
<li><p>使用这款支持scala编译的<a href="https://github.com/saturday06/gradle-android-scala-plugin" target="_blank" rel="external">插件</a>，并根据其read文件来解决可能遇到的<a href="https://developer.android.com/tools/building/multidex.html" target="_blank" rel="external">DEX 64K Methods Limit</a>问题。<br>有两个解决方法：如果使用multidex，参考<a href="https://developer.android.com/tools/building/multidex.html#mdex-gradle" target="_blank" rel="external">Configuring Your App for Multidex with Gradle</a>，步骤并不多。甚至你可以直接使用该<a href="https://github.com/saturday06/gradle-android-scala-plugin/tree/master/sample/simple" target="_blank" rel="external">sample</a>的build配置，在此基础上写程序即可；如果使用proguard，先上网搜索该库的proguard文件，常常会有人已经写出来了，这里<a href="https://github.com/pocorall/hello-scaloid-gradle/blob/master/proguard-rules.txt" target="_blank" rel="external">hello-scaloid-gradle</a>就做了提供。</p>
</li>
<li><p>使用scala来写android app~<br>可以使用一些框架，比如<a href="https://github.com/pocorall/scaloid" target="_blank" rel="external">scaloid</a></p>
</li>
</ol>
<blockquote><p>Scaloid is a library that simplifies your Android code.<br>It makes your code easy to understand and maintain by leveraging Scala language.</p>
</blockquote>
<p><img src="https://camo.githubusercontent.com/72417659473b911df7f1bd03359de67685783ae7/687474703a2f2f6f2d6e322e636f6d2f766572626f736553696d706c652e706e67" alt=""></p>
<p>如上图所示， 确实，即使利用scala多范式语言的特性，就可以对比java写出同样功能但清爽许多的code。但是使用scala无法忽视的一点是，加入了scala语言库这个容量巨大的依赖(或者是因为太复杂的类继承关系)<a href="https://code.google.com/p/android/issues/detail?id=22586" target="_blank" rel="external">issue 22586</a>中讨论的就是sacala引起的LinearAlloc exceeded问题。<br><blockquote><p>由於 Android dex 的種種限制，造成 method 數量有上限的問題，再加上第三方 library 揮霍無度，使得即使你的 App 還很小，卻不小心會撞上這個 64k method 數限制。建議：</p>
<ol>
<li>慎選第三方 library，最好採用前先用 dex-method-count 度量一下</li>
<li>scala, groovy 這類非原生的開發語言想都不要想，它們只會帶來更多的問題。用非 Java 語言開發可以，但是僅限於 NDK</li>
<li>要替 Google play service 瘦身</li>
<li>square 出品的 library 都很適合 Android 使用</li>
<li>Android 2.3 的可用 method 數更少，約 56000，不過這只要 proguard 後達成即可。</li>
</ol>
<footer><strong>預防 Android Dex 64k Method Size Limit</strong><cite><a href="https://ingramchen.io/blog/2014/09/prevention-of-android-dex-64k-method-size-limit.html" target="_blank" rel="external">ingramchen.io/blog/2014/09/prevention-of-android-dex-64k-method-size-limit.html</a></cite></footer></blockquote><br>如果你只是想要用android5.0 以上的device玩玩scala，大概都不会出现问题，但是，用这个写app的话，没办法保证会在什么样的千奇百怪的android device上出现问题。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天大概要宣布第一条路走不通了。</p>
<p>感觉还是有必要把这条路重新理一下。。。毕竟并不是什么效果都没有看到。</p>
<p>任务：在安卓手机上实现akka remote，我也不知道做这件事情到底有什么意义= =</p>
<p>现有条件： </p>
<ol>
<li>一个需要akka跑的scala分布式程序。</li>
<li>丧心病狂的来了，由于某种更加扭曲的实验方式的限制，最终实验必须要在一台g5上跑起来。</li>
</ol>]]>
    
    </summary>
    
      <category term="android" scheme="http://potatoker.github.io/tags/android/"/>
    
      <category term="proguard" scheme="http://potatoker.github.io/tags/proguard/"/>
    
      <category term="scala" scheme="http://potatoker.github.io/tags/scala/"/>
    
      <category term="android" scheme="http://potatoker.github.io/categories/android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[cat]]></title>
    <link href="http://potatoker.github.io/2015/12/23/cat/"/>
    <id>http://potatoker.github.io/2015/12/23/cat/</id>
    <published>2015-12-23T06:33:28.000Z</published>
    <updated>2015-12-23T06:33:28.503Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[learn pyspider]]></title>
    <link href="http://potatoker.github.io/2015/12/20/learn-pyspider/"/>
    <id>http://potatoker.github.io/2015/12/20/learn-pyspider/</id>
    <published>2015-12-20T14:34:32.000Z</published>
    <updated>2015-12-22T05:55:22.499Z</updated>
    <content type="html"><![CDATA[<p>虽然知道当时实验室的活以及随之到来的各种考试已经占满了时间表，但是仅仅因为我自己很想做，还是接下来了。</p>
<h1 id="u5FC3_u8DEF_u5386_u7A0B"><a href="#u5FC3_u8DEF_u5386_u7A0B" class="headerlink" title="心路历程"></a>心路历程</h1><p>大概了解了爬虫的情况之后，觉得还是用框架比较好。<br>当时的需求是：</p>
<ol>
<li>爬的数据量要比较大，当时他们甚至提出多买几台服务器的提议。</li>
<li>需要的信息很多是实时刷新，这也是需要这个审核发布系统的原因，可是随时尽快的得到最新的爬虫数据。</li>
<li>希望可以方便的添加爬虫，也便于这个部分给非技术人员的交接。</li>
</ol>
<a id="more"></a>
<p>然后大概了解了当前的爬虫技术的情况，首先进入视野的当然是scrapy。确实，scrapy非常容易上手，几个组件的工作流程清晰。不过我当时马上遇到了要解析js请求的问题。对于不需要js渲染的网站，当时很快成功了，面对需要渲染的网站：主要办法</p>
<ol>
<li>手动模拟请求方式</li>
<li>配合轻型浏览器作为中间件来渲染网页</li>
</ol>
<p>不过看过了某家网站的请求，发现似乎其request是加密的，每次js request是不一样的，因此觉得第一个办法打了折，并且关于渲染时间和人工分析时间的trade off，目前情况，我还是觉得后者比较昂贵。</p>
<p>至于第二种办法，我找到了这个组件： <a href="http://blog.scrapinghub.com/2015/03/02/handling-javascript-in-scrapy-with-splash/" target="_blank" rel="external">Splash</a>,<a href="http://splash.readthedocs.org/en/stable/" target="_blank" rel="external">文档</a>，其实发现splash的定制化很高，但是文档也很长。没耐心看的时候有点头疼，中间我在调试的时候发现了另外一个爬虫框架：<a href="http://docs.pyspider.org/en/latest/Working-with-Results/" target="_blank" rel="external">pyspider</a>，这是它的描述：</p>
  <blockquote><ul>
<li>Write script in Python  </li>
<li>Powerful WebUI with script editor, task monitor, project manager and result viewer  </li>
<li>MySQL, MongoDB, Redis, SQLite, PostgreSQL with SQLAlchemy as database backend</li>
<li>RabbitMQ, Beanstalk, Redis and Kombu as message queue</li>
<li>Task priority, retry, periodical, recrawl by age, etc…</li>
<li>Distributed architecture, Crawl Javascript pages, Python 2&amp;3, etc…</li>
</ul>
</blockquote>
<p>完全符合需求，更重要的是，文档中也直接给出当时比较头疼的js渲染问题例子，感觉比较适合自己小白的身份。而且文档一点也不长，解释很清楚，所以立马上手试验，对了，关键是有web端控制台，简直就是小白的利器。考虑到当时最主要的解析js的问题，同样目钱的需求是能立刻使功能实现，另外phantomjs也允许做出进一步的渲染需求，所以马上就转手Pyspider了。</p>
<p>以一个小白的身份感受比较深的是这几点好处：</p>
<ol>
<li>组件结构清晰，适应分布式的处理方式，因此也容易根据各个组建的状态分析问题。</li>
<li>控制台友好，方便在其他终端查看服务器上的爬虫状态，更重要的是，在其他终端就可以很方便的进行调试。</li>
<li>组件的配置非常灵活，可以适应不同的爬虫规模。</li>
</ol>
<p>特别是自己感受的前两点，<strong>非常方便找bug和分析问题</strong>，一直觉得调试方便时使用轮子的最重要的一点.<br>另外这个框架是北邮的一位同学写的，在group里是有问必答。感谢轮子主。。。还有比这一点更适合小白的吗<em>(:зゝ∠)</em></p>
<h1 id="u5177_u4F53_u4F7F_u7528"><a href="#u5177_u4F53_u4F7F_u7528" class="headerlink" title="具体使用"></a>具体使用</h1><h2 id="u5B89_u88C5_u8FC7_u7A0B"><a href="#u5B89_u88C5_u8FC7_u7A0B" class="headerlink" title="安装过程"></a>安装过程</h2><p>除了官方文档，参考这位同学的<a href="https://imlonghao.com/9.html" target="_blank" rel="external">博文</a>，这位博主的<a href="https://imlonghao.com/10.html" target="_blank" rel="external">轻松组建分布式 pyspider 集群</a>也是很好的参考。</p>
<h2 id="u4F7F_u7528"><a href="#u4F7F_u7528" class="headerlink" title="使用"></a>使用</h2><p>作者的文档比较清晰，这里有几处花时间较多的点：</p>
<ol>
<li><p>phamtomjs挂掉  </p>
<p>crawl rate这里，作者提到了<a href="http://en.wikipedia.org/wiki/Token_bucket" target="_blank" rel="external">token_bucket</a>，之前有时候会遇到phantomjs挂掉的情况，实验过后发现应该适合crawl rate的设置有关。遇到phamtomjs挂掉的问题，我现在的解决办法是：</p>
</li>
</ol>
<ul>
<li>设置crawl rate变小，默认1/3,我会改成0.5/3，</li>
<li>在不同的端口多开几个phantomjs的process和对应的 fetcher的process</li>
</ul>
<p>其实关于速率这个问题，我还没有仔细的研究过该怎么找到最好的适应不同爬虫规模的那个point，作者也提供了爬虫平均速率在Webui的展示，但是赶着完成其他部分。以后不同规模和环境的爬虫跑起来以后，可能这个问题还是需要搞清楚。</p>
<ol>
<li>重写result处理方法</li>
</ol>
<p>在框架中的result默认处理方式是将所有结构化信息打包成了一个jsonobject存储在了默认以project为名的表中。并且框架不提供关于进一步处理result的接口，这样的话，需要重写result处理这部分的程序。重写on_result方法（刚方法是处理前面爬虫组件传递的result的回调方法）。默认是project, taskid等此类task信息加上一个result jsonobject作为插入数据库的feild，这里，我需要把result json拆分成单独的field插入到指定的表中。重写的<a href="https://github.com/potatoker/pyspider-files" target="_blank" rel="external">my_result_worker</a>这个类将被作为参数指定执行result_worker组件。把这两个文件放到pyspider的根目录下即可。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>虽然知道当时实验室的活以及随之到来的各种考试已经占满了时间表，但是仅仅因为我自己很想做，还是接下来了。</p>
<h1 id="u5FC3_u8DEF_u5386_u7A0B"><a href="#u5FC3_u8DEF_u5386_u7A0B" class="headerlink" title="心路历程"></a>心路历程</h1><p>大概了解了爬虫的情况之后，觉得还是用框架比较好。<br>当时的需求是：</p>
<ol>
<li>爬的数据量要比较大，当时他们甚至提出多买几台服务器的提议。</li>
<li>需要的信息很多是实时刷新，这也是需要这个审核发布系统的原因，可是随时尽快的得到最新的爬虫数据。</li>
<li>希望可以方便的添加爬虫，也便于这个部分给非技术人员的交接。</li>
</ol>]]>
    
    </summary>
    
      <category term="crawler" scheme="http://potatoker.github.io/tags/crawler/"/>
    
      <category term="python" scheme="http://potatoker.github.io/tags/python/"/>
    
      <category term="general tech" scheme="http://potatoker.github.io/categories/general-tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[json使用总结]]></title>
    <link href="http://potatoker.github.io/2015/12/20/json%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://potatoker.github.io/2015/12/20/json使用总结/</id>
    <published>2015-12-20T12:38:30.000Z</published>
    <updated>2016-01-30T12:38:11.039Z</updated>
    <content type="html"><![CDATA[<p>写爬虫的时候真的发现json很好用，作为一种序列化机制。。。恐怕没有更好理解的了。</p>
<p>这里我的数据经历了：</p>
<p><strong>网站–&gt;python爬虫–&gt;mysql数据库&lt;–&gt;php程序&lt;–&gt;java(安卓app)</strong></p>
 <a id="more"></a> 
<p>这里，把上次项目中使用的上述整个数据流的一套方案列在这里，方便今后查阅。</p>
<p>其中：</p>
<h1 id="1-_python_u5230mysql"><a href="#1-_python_u5230mysql" class="headerlink" title="1. python到mysql"></a>1. python到mysql</h1><p> 在爬虫中，将response中需要的数据整合成dict例如：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">         <span class="string">"url"</span>: response.url,</span><br><span class="line">         <span class="string">"title"</span>: response.doc(<span class="string">'.article_title'</span>).text(),</span><br><span class="line">         <span class="string">"price"</span>: response.doc(<span class="string">'.article_title span'</span>).text(),</span><br><span class="line">         <span class="string">"sale_desc"</span>: response.doc(<span class="string">'[itemprop="description"]:first-child'</span>).text(),</span><br><span class="line">         <span class="string">"product_desc"</span>: response.doc(<span class="string">'.wiki-box+.inner-block p:first-child'</span>).text(),</span><br><span class="line"><span class="string">"imglist"</span>: imglist</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该dict将被以**arg的形式传递给数据库操作函数，从而将dict中的item一一对应插入到数据库的表的field中。这其中注意到imglist是一个列表，其他类型都是text(感觉还没有从python implicit声明的习惯中适应)。在pyspider源码中，数据库操作传入的参数是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">obj = &#123;</span><br><span class="line">         <span class="string">'taskid'</span>: taskid,</span><br><span class="line">         <span class="string">'url'</span>: url,</span><br><span class="line">         <span class="string">'result'</span>: result,</span><br><span class="line">         <span class="string">'updatetime'</span>: time.time(),</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> self._replace(tablename, **self._stringify(obj))</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">_stringify</span><span class="params">(self, data)</span>:</span></span><br><span class="line">     <span class="keyword">if</span> <span class="string">'result'</span> <span class="keyword">in</span> data:</span><br><span class="line">         data[<span class="string">'result'</span>] = json.dumps(data[<span class="string">'result'</span>])</span><br><span class="line">     <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>
<p>如果dict中有除字符串以外的数据类型也需要进行“字符串化”，就是这里的_stringfy()函数,其实就是进行json格式的转换。所以同理，在重写的result_worker中也应该吧imglist这个python中的list转换为json,在放入dict传递给数据库操作函数:</p>
<pre><code>imgjson = json.dumps(imgList)
</code></pre><p>这样return的dict就可以放心交给result_worker，其实json化这一步也可以放在<a href="https://github.com/potatoker/pyspider-files/blob/master/result_worker/my_result_worker.py" target="_blank" rel="external">my_result_worker</a>中，因为在on_result方法中才会把整个dict传给数据库操作类SQL。</p>
<p>所以总结的话，常常会用到把python中的数据映射到数据库中，由于python的dict和**args参数形式十分好用，所以只用把需要的数据库field组织成dict，这个dict的各个值都是字符串，如果有数据不是的话就将其jsondump然后传给数据库操作函数就可以了。把pyspider的源码抄过来：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">replace</span><span class="params">(self,tablename=None,**values)</span>:</span></span><br><span class="line">   <span class="keyword">if</span> SQL.connection == <span class="string">''</span>:</span><br><span class="line">       <span class="keyword">print</span> <span class="string">"Please connect first"</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">   tablename = self.escape(tablename )</span><br><span class="line">   <span class="keyword">if</span> values:</span><br><span class="line">       _keys = <span class="string">", "</span>.join(self.escape(k) <span class="keyword">for</span> k <span class="keyword">in</span> values)</span><br><span class="line">       _values = <span class="string">", "</span>.join([self.placeholder, ] * len(values))</span><br><span class="line">       sql_query = <span class="string">"REPLACE INTO %s (%s) VALUES (%s)"</span> % (tablename, _keys, _values)</span><br><span class="line">   <span class="keyword">else</span>:</span><br><span class="line">       sql_query = <span class="string">"REPLACE INTO %s DEFAULT VALUES"</span> % tablename</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   cur = SQL.connection.cursor()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span>:</span><br><span class="line">       <span class="keyword">if</span> values:</span><br><span class="line">           cur.execute(sql_query, list(itervalues(values)))</span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">           cur.execute(sql_query)</span><br><span class="line"></span><br><span class="line">       SQL.connection.commit()</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">   <span class="keyword">except</span> mysql.connector.Error <span class="keyword">as</span> err:</span><br><span class="line">       <span class="keyword">print</span> (<span class="string">"An error occured: &#123;&#125;"</span>.format(err))</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<p>这种程序数据到数据库数据的映射简直是万金油啊，不要太好用。完整的SQL文件在<a href="https://github.com/potatoker/pyspider-files/blob/master/result_worker/mymysql.py" target="_blank" rel="external">这里</a>。</p>
<p>在数据库中，可以看到在数据库中imglist的形式是[‘aa’,’bb’]，当然是字符串，但是在今后的额decode的时候来看，这是一个jsonArray.完整的映射表如下:</p>
<p>  <img src="http://images.cnblogs.com/cnblogs_com/coser/201112/201112141621136287.png" alt=""></p>
<p>在源码中result作为一个dict被jsondump()之后插入数据库的field，在数据库中显示<code>{&quot;name&quot;:&quot;dd&quot;,&quot;hobby&quot;:&quot;aa&quot;}</code>,是一个jsonobject.</p>
<h1 id="2-_mysql-_26gt_3Bphp"><a href="#2-_mysql-_26gt_3Bphp" class="headerlink" title="2. mysql-&gt;php"></a>2. mysql-&gt;php</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="variable">$row</span>=mysql_fetch_array(<span class="variable">$result</span>,MYSQL_ASSOC))</span><br><span class="line">&#123;</span><br><span class="line">  	<span class="keyword">echo</span> urldecode(json_encode(<span class="variable">$row</span>));</span><br><span class="line">  	<span class="keyword">echo</span> <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>游标中的一个row被取下来之后，转换成json然后echo出去。</p>
<h1 id="3-_php-_26gt_3Bjava"><a href="#3-_php-_26gt_3Bjava" class="headerlink" title="3. php-&gt;java"></a>3. php-&gt;java</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">JSONObject json = <span class="keyword">new</span> JSONObject(result);</span><br><span class="line">details = json.getString(<span class="string">"details"</span>);</span><br><span class="line">JSONArray images = json.getJSONArray(<span class="string">"imglist"</span>);<span class="comment">//imglist代表的项是一个list</span></span><br><span class="line"> 	 <span class="comment">//把imglist里的网址(string 类型)传递给了java array</span></span><br><span class="line">String[] banImages = <span class="keyword">new</span> String[images.length()];						</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; images.length(); i++)&#123;</span><br><span class="line">	String image = images.getString(i);</span><br><span class="line">	banImages[i] = image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>php echo的字节流进入socket的inputstream，这个字节流的一行就是sql执行的row，通过readline就可以取出这一行，这一行在php里经过json_encode，所以在java这边作为一个JSONObject，然后进行解析，通过get函数来取出每一个field，这样就最终得到需要的粒化的数据了。</p>
<h1 id="4-_java-_26gt_3Bphp"><a href="#4-_java-_26gt_3Bphp" class="headerlink" title="4. java-&gt;php"></a>4. java-&gt;php</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JSONObject checkState = <span class="keyword">new</span> JSONObject();</span><br><span class="line"></span><br><span class="line">checkState.put(<span class="string">"name"</span>, <span class="string">"Raymond"</span>);</span><br><span class="line"></span><br><span class="line">JsonArray keptIds = <span class="keyword">new</span> JsonArray(keptIdList)<span class="comment">//keptIdList是一个java List类型</span></span><br><span class="line"></span><br><span class="line">checkState.put(keptIds.toString());</span><br></pre></td></tr></table></figure>
<p>把一个java对象的各个变量put到这个JSONObject中就可以了。</p>
<p>发送过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String uploadString = checkState.toString()<span class="comment">//这里checkstate被转换为String,将被通过outputstream传递给server上的php，</span></span><br><span class="line"></span><br><span class="line">String content = URLEncoder.encode(<span class="string">"checkstate"</span>, <span class="string">"UTF-8"</span>) + <span class="string">"="</span></span><br><span class="line">							+ URLEncoder.encode(uploadString ,<span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">out.writeBytes(content);</span><br></pre></td></tr></table></figure>
<p>整个传输的例子还有诸如<a href="http://stackoverflow.com/questions/19627524/post-data-in-json-format-to-php-script-with-java" target="_blank" rel="external">这里</a></p>
<h1 id="5_php-_26gt_3Bmysql"><a href="#5_php-_26gt_3Bmysql" class="headerlink" title="5 php-&gt;mysql"></a>5 php-&gt;mysql</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$checkstate</span> = <span class="variable">$_POST</span>[<span class="string">'checkstate'</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable">$checkobj</span> =  json_decode(<span class="variable">$checkstate</span>，<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$sql</span> = <span class="string">"insert into footable(kept_ids, name) values("</span>.<span class="string">"'$checkstate['keptIds'],"</span><span class="string">',".'</span> <span class="variable">$checkstate</span>[<span class="string">'name'</span>]).<span class="string">'";";</span></span><br></pre></td></tr></table></figure>
<p>通过<a href="http://php.net/manual/en/function.json-decode.php" target="_blank" rel="external">json_decode</a>把从post变量里得到的jsonobj转换成php的关联数组(第二个参数true就是指定成关联数组返回)，这样就可以以键值对的方式获取jsonobj里的数据了。</p>
<h1 id="6_About_the_List"><a href="#6_About_the_List" class="headerlink" title="6 About the List"></a>6 About the List</h1><p>可以发现一个细节是</p>
<pre><code>checkState.put(keptIds.toString());//keptIds类型为JSONArray
</code></pre><p>这里，我之前犯的一个错误是，在mysql中keptIds的数据类型是varchar型（或mediumbob），并且php中的Insert语句中，从checkob中取值仍然如<strong>5</strong>中代码一样。<br>但我使用：</p>
<pre><code>checkState.put(keptIds);//keptIds类型为JSONArray
</code></pre><p>最终在mysql中,keptIds这一column显示的值是‘Array’，没错，字符串‘Array’，显然，信息丢失了。</p>
<p>目前的数据都是String类型，发现也是最好操作的。包括，python例子中的imgjson它存到数据库中就是一个字符串。</p>
<p><strong>总之，为了在网络上传递复杂的数据类型，json用统一的格式来组织数据，并以字符的形式在网络上进行传输，就像是一种中间表达，沟通客户端与服务端的数据表达。</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>写爬虫的时候真的发现json很好用，作为一种序列化机制。。。恐怕没有更好理解的了。</p>
<p>这里我的数据经历了：</p>
<p><strong>网站–&gt;python爬虫–&gt;mysql数据库&lt;–&gt;php程序&lt;–&gt;java(安卓app)</strong></p>]]>
    
    </summary>
    
      <category term="java" scheme="http://potatoker.github.io/tags/java/"/>
    
      <category term="json" scheme="http://potatoker.github.io/tags/json/"/>
    
      <category term="php" scheme="http://potatoker.github.io/tags/php/"/>
    
      <category term="python" scheme="http://potatoker.github.io/tags/python/"/>
    
      <category term="general tech" scheme="http://potatoker.github.io/categories/general-tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[are you ok]]></title>
    <link href="http://potatoker.github.io/2015/12/13/are-you-ok/"/>
    <id>http://potatoker.github.io/2015/12/13/are-you-ok/</id>
    <published>2015-12-13T08:03:20.000Z</published>
    <updated>2015-12-13T08:27:21.993Z</updated>
    <content type="html"><![CDATA[<p>总算是要准备开始写博客了！</p>
<p>之前一直都是在用evernote当博客。。。</p>
<p>这边可以用markdown感觉以后可能会把这个博客当做笔记吧==</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>总算是要准备开始写博客了！</p>
<p>之前一直都是在用evernote当博客。。。</p>
<p>这边可以用markdown感觉以后可能会把这个博客当做笔记吧==</p>
]]>
    </summary>
    
      <category term="helo, blog" scheme="http://potatoker.github.io/tags/helo-blog/"/>
    
  </entry>
  
</feed>
