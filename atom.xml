<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[RRRay]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://potatoker.github.io/"/>
  <updated>2016-08-17T03:02:11.778Z</updated>
  <id>http://potatoker.github.io/</id>
  
  <author>
    <name><![CDATA[RRRay]]></name>
    <email><![CDATA[kknightgo@gmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[单例]]></title>
    <link href="http://potatoker.github.io/2016/08/17/%E5%8D%95%E4%BE%8B/"/>
    <id>http://potatoker.github.io/2016/08/17/单例/</id>
    <published>2016-08-17T02:38:30.000Z</published>
    <updated>2016-08-17T03:02:11.778Z</updated>
    <content type="html"><![CDATA[<p>最近复习，顺藤摸瓜的对一些java基础进行了巩固。</p>
<a id="more"></a>
<p>首先，在所有的解释中<a href="http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/" target="_blank" rel="external">如何正确地写出单例模式-黑桃夹克</a>是比较详细的，多有参考。</p>
<p>首先单例分为懒汉式和饿汉式</p>
<p>分类的区别在于:</p>
<p>懒汉式:单例是在需要的时候才会被初始化(相对饿汉式来说初始化被推迟了，所以称为”懒汉式”)<br>饿汉式:单例在类被加载的会后就被初始化</p>
<p>另外，不同的实现又分为线程安全和线程不安全:</p>
<p>目前来讲，实现线程安全的方式，就是使用synchronized关键字。<br>为什么线程安全要被提出，因为，作为单例，程序里只有一个实例，那么如果这是一个多线程的程序的话，很容易出现多线程同时访问同一个实例的同步问题。</p>
<h2 id="1-__u61D2_u6C49_u5F0F_uFF0C_u7EBF_u7A0B_u4E0D_u5B89_u5168"><a href="#1-__u61D2_u6C49_u5F0F_uFF0C_u7EBF_u7A0B_u4E0D_u5B89_u5168" class="headerlink" title="1. 懒汉式，线程不安全"></a>1. 懒汉式，线程不安全</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">         instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到是通过调用<code>getInstance</code>的时候才初始化的，同时，要在调用的时候检验单例是否初始化，如果已经初始过，自然不需要初始化。</p>
<h2 id="2-__u61D2_u6C49_u5F0F_uFF0C_u7EBF_u7A0B_u5B89_u5168"><a href="#2-__u61D2_u6C49_u5F0F_uFF0C_u7EBF_u7A0B_u5B89_u5168" class="headerlink" title="2. 懒汉式，线程安全"></a>2. 懒汉式，线程安全</h2><p>然而上面的是线程不安全的，所有线程可以同时拿到单例，并进行操作，这种同时操作如果有需要同步的写操作的话，自然会造成紊乱。</p>
<p>那么这里很简单的想法，就是把这个<code>getInstance</code>函数变成线程同步的。这样就不允许多个线程同时拿到单例的情况发生了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-__u61D2_u6C49_u5F0F_uFF0C_u7EBF_u7A0B_u5B89_u5168_uFF0C_u53CC_u91CD_u68C0_u9A8C_u9501"><a href="#3-__u61D2_u6C49_u5F0F_uFF0C_u7EBF_u7A0B_u5B89_u5168_uFF0C_u53CC_u91CD_u68C0_u9A8C_u9501" class="headerlink" title="3. 懒汉式，线程安全，双重检验锁"></a>3. 懒汉式，线程安全，双重检验锁</h2><p>然而上面的最简单的懒汉式有个问题，就是很有可能有一种情况，就是，其实是允许大家同时对单例进行读或写的操作的，最典型的例子，是volley，大家只是想拿到单例往里面的队列放任务而已，而入队操作本来就允许多个线程同时执行啊。</p>
<p>所以这种需求下，我唯一需要同步的部分是<code>getInstance</code>函数里面，当我要进行单例初始化操作的时候，这个操作肯定是需要同步的。</p>
<p>那么就有了双重检验锁的诞生:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;                         <span class="comment">//Single Checked</span></span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;                 <span class="comment">//Double Checked</span></span><br><span class="line">                instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，复习一下<code>synchronized (Singleton.class)</code>,如果要同步整个成员函数，那么synchronized的内部锁其实是<code>this</code>，可是如果要同步一个静态函数(没有this调用),那么内部锁是类对象，即<code>Singleton.class</code></p>
<h4 id="volatile_u5173_u952E_u5B57"><a href="#volatile_u5173_u952E_u5B57" class="headerlink" title="volatile关键字"></a>volatile关键字</h4><p>然而，这个程序是不完全的！！！</p>
<p>错误点的解释:</p>
<ol>
<li>初始化一个对象的操作并不是在一瞬间完成的，他是由多条指令构成的</li>
<li>java中的语句可能是由多条指令构成的，然而编译器可能对这一条语句对应的多条指令进行指令重排进行执行优化</li>
<li>在上面的程序里，考虑一种情况：线程1第一个调用getSingleton,由他来进行初始化，然而这个初始化过程，包括给(1)给Singleton在heap中划分空间，把地址传给引用(2)初始化其成员变量…等等，</li>
<li>有可能是引用已经不为空，但是实际上对象还没有初始化好的情况。在这个时间点，如果有线程2来调用Singleton，他会发现引用已经不为空，不会进入同步的初始化单例的语句，而是直接读这个单例了，但实际上这个单例根本还没被初始化好。</li>
</ol>
<p>网上基本上解释为指令重排带来的错误，我这里觉得有可能是分配引用和真正construct这块引起的问题。</p>
<p>那么解决办法是?<br><strong>使用volatile关键字标识对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance; <span class="comment">//声明成 volatile</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;                         </span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;       </span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>volitile关键字会保证该变量的操作一定是满足happens-before原则</p>
<p>通过保证:</p>
<ol>
<li>所有线程的读写都是在main memory进行，不会是在cache中进行</li>
<li>对该变量的操作屏蔽了指令重排</li>
</ol>
<p><a href="http://stackoverflow.com/questions/11639746/what-is-the-point-of-making-the-singleton-instance-volatile-while-using-double-l" target="_blank" rel="external">SO</a><br>中的解释</p>
<blockquote>
<p>The volatile prevents memory writes from being re-ordered, making it impossible for other threads to read uninitialized fields of your singleton through the singleton’s pointer.</p>
<p>Consider this situation: thread A discovers that uniqueInstance == null, locks, confirms that it’s still null, and calls singleton’s constructor. The constructor makes a write into member XYZ inside Singleton, and returns. Thread A now writes the reference to the newly created singleton into uniqueInstance, and gets ready to release its lock.</p>
<p>Just as thread A gets ready to release its lock, thread B comes along, and discovers that uniqueInstance is not null. Thread B accesses uniqueInstance.XYZ thinking that it has been initialized, but because the CPU has reordered writes, the data that thread A has written into XYZ has not been made visible to thread B. Therefore, thread B sees an incorrect value inside XYZ, which is wrong.</p>
<p>When you mark uniqueInstance volatile, a memory barrier is inserted. All writes initiated prior to that of uniqueInstance will be completed before the uniqueInstance is modified, preventing the reordering situation described above.</p>
</blockquote>
<p>这里说的就是先分配引用再初始化的问题，这里看到了网上的另外一些更explicit的<a href="http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html" target="_blank" rel="external">说法</a>:</p>
<blockquote>
<p>As you can see, the assignment to singletons[i].reference is performed before the constructor for Singleton is called. This is completely legal under the existing Java memory model, and also legal in C and C++ (since neither of them have a memory model).</p>
</blockquote>
<h2 id="4-__u997F_u6C49_u5F0F_static_final_field"><a href="#4-__u997F_u6C49_u5F0F_static_final_field" class="headerlink" title="4. 饿汉式 static final field"></a>4. 饿汉式 static final field</h2><p>上面的懒汉式由于是推迟构造，构造这个动作要是同步的，同时读写又可能不需要同步，造成了上面那些麻烦的事情。</p>
<p>这里饿汉式就是直接把单例设为静态变量，单例的初始化是在类被加载的时候(虽然类被加载可能是由线程调用getInstance触发的)，是由jVM去完成的，而不是线程。所以线程间的初始化单例的动作是线程安全的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">//类加载时就初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里复习一下几个东西:</p>
<ol>
<li>什么时候一个类会被load</li>
<li>什么时候一个类中的static field会被初始化</li>
<li>为什么这里单例作为static field初始化时线程安全的?</li>
</ol>
<p>####对于1 ：什么时候一个类会被load</p>
<p><a href="http://www.programcreek.com/2013/01/when-and-how-a-java-class-is-loaded-and-initialized/" target="_blank" rel="external">这篇文章</a>有详细说明</p>
<blockquote>
<p>We can see the difference highlighted in red. A.class is loaded only when it is used. In summary, a class is loaded:</p>
<ul>
<li>when the new bytecode is executed. For example, SomeClass f = new SomeClass();</li>
<li>when the bytecodes make a static reference to a class. For example, System.out.</li>
</ul>
</blockquote>
<p>其实就是之前操作系统复习到的动态加载，这样才算作节省资源并且合理分配资源。</p>
<h4 id="u5BF9_u4E8E2_uFF1A_u4EC0_u4E48_u65F6_u5019_u4E00_u4E2A_u7C7B_u4E2D_u7684static_field_u4F1A_u88AB_u521D_u59CB_u5316"><a href="#u5BF9_u4E8E2_uFF1A_u4EC0_u4E48_u65F6_u5019_u4E00_u4E2A_u7C7B_u4E2D_u7684static_field_u4F1A_u88AB_u521D_u59CB_u5316" class="headerlink" title="对于2：什么时候一个类中的static field会被初始化"></a>对于2：什么时候一个类中的static field会被初始化</h4><p>首先，类的成员变量，或者说实例的成员变量，什么时候被初始化，被new的时候啊。这个不用多说，那么，主要的问题就在这个静态变量.</p>
<blockquote>
<p>After class loading, initialization of class takes place which means initializing all static members of class.</p>
</blockquote>
<p><a href="http://stackoverflow.com/questions/3499214/when-does-static-class-initialization-happen" target="_blank" rel="external">这篇SO</a>和<a href="http://javarevisited.blogspot.com/2012/07/when-class-loading-initialization-java-example.html" target="_blank" rel="external">这篇</a>有个很官方的说法</p>
<blockquote>
<p>A classes static initialization normally happens immediately before the first time one of the following events occurs:</p>
<ul>
<li>an instance of the class is created,</li>
<li>a static method of the class is invoked,</li>
<li>a static field of the class is assigned,</li>
<li>an static field of class is used which is not a constant variable.</li>
<li>for a top-level class, an assert statement lexically nested within the class is executed.</li>
</ul>
</blockquote>
<p>这不也就是动态加载那一套吗嘛.总结一下就是，<br><strong>类中的静态变量是在用到这个静态变量的时候才会被初始化的</strong></p>
<p>这个初始化包括这个静态变量所在类的加载，和这个静态变量的初始化。</p>
<p><a href="http://stackoverflow.com/questions/2007666/in-what-order-do-static-initializer-blocks-in-java-run" target="_blank" rel="external">这篇SO</a>的答案就是说的这样干脆:</p>
<blockquote>
<p>The static initializer for a class gets run when the class is first accessed, either to create an instance, or to access a static method or field.So, for multiple classes, this totally depends on the code that’s run to cause those classes to get loaded.</p>
</blockquote>
<p>所以很不严谨的用人话回答上面的那个问题:</p>
<ol>
<li>类被用于创建实例(new)或用到了成员变量的时候，反正就是被使用的时候</li>
<li>类被加载的时候</li>
</ol>
<p>最后最后回到我们的饿汉式。</p>
<p>看完了上面这些，我就会发现，这个单例作为static field，那么只有当我用到这个静态单例变量的时候才会被初始化，这不就是我们想要吗?</p>
<p>如果你的单例类，真的<strong>只有</strong>上面写的那一部分。确实，这个饿汉式就是lazy mode，即用即初始化。</p>
<p>but,你可能还有别的静态变量，别的静态函数在这个单例类里面啊。</p>
<p>而只要<strong>任何一个</strong>静态field被用到了，这个类就会被load，这个类一被load,那这个类的<strong>所有</strong>静态变量都会被初始化！！</p>
<p><a href="http://stackoverflow.com/questions/7790185/singleton-lazy-vs-eager-instantiation" target="_blank" rel="external">这篇SO</a>就是说明了这个问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;     </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Logger instance = <span class="keyword">new</span> Logger(); </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> String LOG_LINE_SEPERATOR =  </span><br><span class="line">      System.getProperty(<span class="string">"line.separator"</span>);</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Logger <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">          <span class="keyword">return</span> instance;     </span><br><span class="line">   &#125; </span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">logPattern</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Logger.LOG_LINE_SEPERATOR; <span class="comment">// load Logger instance or</span></span><br><span class="line">Logger.logPattern(); <span class="comment">// load Logger instance</span></span><br></pre></td></tr></table></figure>
<p>他这里就演示了一段有其他静态变量的单例类，然后就发现，用到这个Looger静态变量的时候，单例也被初始化了，这就不是懒汉式了，因为我们此时并不需要单例。</p>
<h4 id="u5BF9_u4E8E3_uFF0C_u4E3A_u4EC0_u4E48_u5355_u4F8B_u4F5C_u4E3Astatic_field_u88AB_u521D_u59CB_u5316_u7684_u65F6_u5019_u662F_u7EBF_u7A0B_u5B89_u5168_u7684_28_u6211_u4EEC_u81EA_u5DF1_u6CA1_u6709_u5BF9_u8FD9_u4E2A_u52A8_u4F5C_u8FDB_u884C_u540C_u6B65_u64CD_u4F5C_29"><a href="#u5BF9_u4E8E3_uFF0C_u4E3A_u4EC0_u4E48_u5355_u4F8B_u4F5C_u4E3Astatic_field_u88AB_u521D_u59CB_u5316_u7684_u65F6_u5019_u662F_u7EBF_u7A0B_u5B89_u5168_u7684_28_u6211_u4EEC_u81EA_u5DF1_u6CA1_u6709_u5BF9_u8FD9_u4E2A_u52A8_u4F5C_u8FDB_u884C_u540C_u6B65_u64CD_u4F5C_29" class="headerlink" title="对于3，为什么单例作为static field被初始化的时候是线程安全的(我们自己没有对这个动作进行同步操作)"></a>对于3，为什么单例作为static field被初始化的时候是线程安全的(我们自己没有对这个动作进行同步操作)</h4><p>因为虚拟机初始化这些静态变量的时候会自动给他们加锁，所以一定是线程安全的</p>
<blockquote>
<p>VM runs static initializer blocks and set defaults values for the static fields. This phase uses a special VM lock, one per class or interface, and is what makes singletons thread-safe</p>
</blockquote>
<h2 id="5-__u9759_u6001_u5185_u90E8_u7C7B_static_nested_class"><a href="#5-__u9759_u6001_u5185_u90E8_u7C7B_static_nested_class" class="headerlink" title="5. 静态内部类 static nested class"></a>5. 静态内部类 static nested class</h2><p>好了，看完了上面的，其实我们想要的就是线程安全的，同时是懒汉式初始化的一种单例的实现。目前能够达到这两点的只有double check，但那个方法真的看起来非常不elegent.并且对java版本有要求。</p>
<p>而只有这个方法，我觉的是满足上面两个需求，并且是懒汉式的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE; </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对比上面的饿汉式，其实在单例初始化的线程安全这一点都是用静态变量在类装载时初始化这个原理来保证的。</p>
<p>先看一个问题:</p>
<hr>
<h4 id="u5185_u90E8_u7C7B_u7684load_u662F_u5728_u4EC0_u4E48_u65F6_u5019_u53D1_u751F_u7684"><a href="#u5185_u90E8_u7C7B_u7684load_u662F_u5728_u4EC0_u4E48_u65F6_u5019_u53D1_u751F_u7684" class="headerlink" title="内部类的load是在什么时候发生的"></a>内部类的load是在什么时候发生的</h4><p>答案是，不管是静态内部类还是非静态内部类他们的Load时机完全和上面通用的类的加载是一样的.</p>
<p><a href="http://stackoverflow.com/questions/25192561/when-is-a-static-nested-class-and-static-members-therein-loaded-into-memory" target="_blank" rel="external">这篇SO</a>阐述了相同的疑问:</p>
<blockquote>
<p>There is nothing particularly special about static nested classes. They are loaded the same way as non static and/or non nested classes. To the JVM, all classes are the same and it doesn’t really understand nesting the way Java does</p>
</blockquote>
<p>那我们就知道，虽然SingletonHolder是个Singleton的内部类，但它和普通的类没什么不同，即使Singleton被load了，被初始化了，跟SingletonHolder没一点关系，SingletonHolder跟Singleton唯一的关系是，这个类的表示方式是:<br><code>Singleton$SingletonHolder</code></p>
<p>而静态内部类和非静态内部类唯一的区别是非静态内部类含有外部类实例的引用。这里我们根本不需要用到这个，而且混乱了逻辑，所以只用静态内部类。</p>
<hr>
<p><em>那么怎么实现初始化的lazy mode的呢?</em></p>
<p>上面饿汉式之所以不满足逻辑上的Lazy mode,是因为你不能保证单例类只有他那一个静态变量或者静态函数。</p>
<p>好，既然单例类可能要有别的静态变量，那我就为你这个单例实例单独创建一个类，保证这个类只有单例你一个静态变量，并且只有外面单例类的<code>getInstance</code>会用到这个静态变量(单例)。</p>
<p>这样就保证了，即使单例类有各种乱起八糟其他的静态变量啊，静态函数啊，随便用，都不会影响到单例的初始化，只有完完全全符合我们真正需求的<code>getInstance</code>会触发这个静态内部类的load以及其中单例的初始化。至此完美的达成了即用即初始化的想法。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近复习，顺藤摸瓜的对一些java基础进行了巩固。</p>]]>
    
    </summary>
    
      <category term="java，basic" scheme="http://potatoker.github.io/tags/java%EF%BC%8Cbasic/"/>
    
      <category term="java" scheme="http://potatoker.github.io/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hadoop homework]]></title>
    <link href="http://potatoker.github.io/2016/01/09/hadoop%E6%B5%81%E6%B0%B4%E8%B4%A6/"/>
    <id>http://potatoker.github.io/2016/01/09/hadoop流水账/</id>
    <published>2016-01-09T12:53:30.000Z</published>
    <updated>2016-01-09T13:13:17.236Z</updated>
    <content type="html"><![CDATA[<p>本来想要多花时间把这份作业尽量做好，结果懒癌晚期让我在deadline前两天才开始做。。。</p>
<p>其实现在自己连门都没入，不过近段时间恐怕都没有时间继续学习hadoop了，所以下次做实验最好能尽快回忆起已学的记下这篇流水账，。<br>此外发现自己对linux仍然各种不熟，，，形成了这篇本质流水账</p>
<p>project基于hadoop 1.0.4. 属于很早的版本</p>
<a id="more"></a>
<h1 id="1-_hadoop_u5B89_u88C5"><a href="#1-_hadoop_u5B89_u88C5" class="headerlink" title="1. hadoop安装"></a>1. hadoop安装</h1><p>我装的是hadoop 1.0.4,似乎hadoop几次更新改变都很大，不过作为入门，安全起见，还是使用了老师演示版本。并且也选择了对应的Jdk6</p>
<h2 id="1-__u9884_u7F6E_u8F6F_u4EF6"><a href="#1-__u9884_u7F6E_u8F6F_u4EF6" class="headerlink" title="1. 预置软件"></a>1. 预置软件</h2><h3 id="1-jdk"><a href="#1-jdk" class="headerlink" title="1.jdk"></a>1.jdk</h3><p>sudo apt-get install openjdk-6-jdk</p>
<p>安装完之后增加到环境变量</p>
<pre><code>export JAVA_HOME=/usr/lib/jvm/java-6-openjdk-amd64   

export PATH=$PATH:$JAVA_HOME/bin 
</code></pre><p>用来检查是否生效：</p>
<pre><code>javac -version  
</code></pre><h3 id="2-_ssh"><a href="#2-_ssh" class="headerlink" title="2. ssh"></a>2. ssh</h3><pre><code>sudo apt-get install ssh
</code></pre><p>查看是否启动</p>
<pre><code>$ps -e|grep ssh
</code></pre><p><em>-e Select all processes. Identical to -A.</em><br><em>-f does full-format listing.</em></p>
<p>如果看到sshd和ssh-agent两个进程，则成功。</p>
<h2 id="2-__u5B89_u88C5hadoop"><a href="#2-__u5B89_u88C5hadoop" class="headerlink" title="2. 安装hadoop"></a>2. 安装hadoop</h2><p>1.创建用户组hadoop以及用户hadoopu：          </p>
<pre><code>sudo addgroup hadoop 

sudo adduser --ingroup hadoop hadoopu
</code></pre><p>2.将下载的hadoop.tar.gz拷入hadoopu家目录下：</p>
<pre><code>cp /downloads/hadoop-1.0.4-bin.tar.gz /home/hadoopu/
</code></pre><p>3.解压hadoop包</p>
<pre><code>tar xzf hadoop-1.0.4-bin.tar.gz
</code></pre><p>4.进入hadoop-env.sh所在目录（hadoop-1.0.4/conf/），对该文件进行如下内容的修改：</p>
<pre><code>export JAVA_HOME=/usr/lib/jvm/java-6-openjdk-amd64
</code></pre><p>（/usr/lib/jvm/java-6-openjdk-amd64为jdk安装目录）</p>
<p>5.为了方便更改环境变量，将环境变量的设置写入/etc/profile：</p>
<pre><code>export JAVA_HOME=/usr/lib/jvm/java-6-openjdk-amd64 
export HADOOP_HOME=/home/hadoopu/hadoop-1.0.4 
export PATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin 
export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/htmlconverter.jar:$JAVA_HOME/lib/jconsole.jar:$JAVA_HOME/lib/sa-jdi.jar
</code></pre><p>执行该文件，使配置生效：</p>
<pre><code>source /etc/profile
</code></pre><blockquote><p>The /etc/profile file contains system wide environment stuff and startup programs.</p>
<p>The /etc/profile file is used to set system wide environmental variables on users shells. The variables are sometimes the same ones that are in the .bash_profile, however this file is used to set an initial PATH or PS1 for all shell users of the system.</p>
</blockquote>
<p>ok. 至此安装完成了</p>
<h1 id="2-__u5728_u96C6_u7FA4_u4E0A_u8FD0_u884Cmapreduce_u7A0B_u5E8F"><a href="#2-__u5728_u96C6_u7FA4_u4E0A_u8FD0_u884Cmapreduce_u7A0B_u5E8F" class="headerlink" title="2. 在集群上运行mapreduce程序"></a>2. 在集群上运行mapreduce程序</h1><h2 id="1-__u5C06Master_u7684pubkey_u62F7_u8D1D_u5230slave_u4E0A"><a href="#1-__u5C06Master_u7684pubkey_u62F7_u8D1D_u5230slave_u4E0A" class="headerlink" title="1. 将Master的pubkey拷贝到slave上"></a>1. 将Master的pubkey拷贝到slave上</h2><p>如果没有生产过ssh-key:</p>
<pre><code>ssh-keygen -t rsa -b 4096 -C &quot;mypc&quot;
</code></pre><p>放到目标上机器，一步到位最方便的ssh-copy-id：</p>
<pre><code>ssh-copy-id username@hostname
</code></pre><h2 id="2-__u4E3Aproject_u521B_u5EFA_u6587_u4EF6_u5939_u53CAconf_u6587_u4EF6"><a href="#2-__u4E3Aproject_u521B_u5EFA_u6587_u4EF6_u5939_u53CAconf_u6587_u4EF6" class="headerlink" title="2. 为project创建文件夹及conf文件"></a>2. 为project创建文件夹及conf文件</h2><p>在/home/hadoopu下：  </p>
<pre><code>mkdir HadoopClusterTest  

cd HadoopClusterTest/ 

mkdir conf  

cp HADOOP_HOME/conf/* conf
</code></pre><p>编辑相关配置文件：  </p>
<p>core-site.xml: 用于配置Common组件的属性<br>hdfs-site.xml: 用于配置HDFS的属性<br>mapred-site.xml: 用于配置MapReduce的属性<br>masters 指定master节点 slaves 指定slave节点</p>
<p>这个project <a href="https://github.com/potatoker/hadoop-nbCliassifier/tree/master/conf" target="_blank" rel="external">conf</a>只是对老师的示例conf做了非常简单的改变.<br>这个conf包括的只是最基本的一些配置，许多属性的设置都是默认值，今后需要更好的理解hadoop才可以完善各项配置。</p>
<p>另：可以自己添加属性。</p>
<figure class="highlight pf"><figcaption><span>core-site.xml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&lt;property&gt;</span></span><br><span class="line"><span class="variable">&lt;name&gt;</span>token_in_class_num_path<span class="variable">&lt;/name&gt;</span></span><br><span class="line"><span class="variable">&lt;value&gt;</span>hdfs://localhost/<span class="keyword">user</span>/hadoopu/classfnum/part-r-<span class="number">00000</span><span class="variable">&lt;/value&gt;</span></span><br><span class="line"><span class="variable">&lt;/property&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后在程序中，conf读入了配置文件的键值对，包括自己添加的.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Configuration conf;  </span><br><span class="line"><span class="keyword">private</span> FileSystem fs;    </span><br><span class="line">conf = context.getConfiguration();  </span><br><span class="line">fs = FileSystem.get(<span class="keyword">new</span> URI(<span class="string">"hdfs:///"</span>), conf);  </span><br><span class="line">Path token_in_class_num_path = <span class="keyword">new</span>  Path(conf.get(TOKEN_IN_CLASS_NUM_PATH));</span><br></pre></td></tr></table></figure></p>
<p>在project的应用是训练结果作为sequencefile放在hdfs中，分类时在程序中通过conf获取该训练结果文件所在路径，从而将文件内容读入程序.</p>
<p><strong>这里我想使用自己目录下的配置文件，需要修改环境变量:</strong></p>
<pre><code>export HADOOP_CONF_DIR=~/HadoopClusterTest/conf 
</code></pre><p>这一步十分关键，好几次自己忽略了，因而产生问题。</p>
<h2 id="3-_u542F_u52A8hadoop"><a href="#3-_u542F_u52A8hadoop" class="headerlink" title="3.启动hadoop"></a>3.启动hadoop</h2><h3 id="1-_u683C_u5F0F_u5316hdfs_3A"><a href="#1-_u683C_u5F0F_u5316hdfs_3A" class="headerlink" title="1.格式化hdfs:"></a>1.格式化hdfs:</h3><pre><code>hadoop fs namenode -format
</code></pre><h3 id="2-__u5728master_u4E0A_u542F_u52A8hadoop_u5B88_u62A4_u8FDB_u7A0B"><a href="#2-__u5728master_u4E0A_u542F_u52A8hadoop_u5B88_u62A4_u8FDB_u7A0B" class="headerlink" title="2. 在master上启动hadoop守护进程"></a>2. 在master上启动hadoop守护进程</h3><pre><code>start-all.sh
</code></pre><h3 id="3-_u4F7F_u7528jps_u67E5_u770B_u5168_u90E8hadoop_u76F8_u5173_u8FDB_u7A0B"><a href="#3-_u4F7F_u7528jps_u67E5_u770B_u5168_u90E8hadoop_u76F8_u5173_u8FDB_u7A0B" class="headerlink" title="3.使用jps查看全部hadoop相关进程"></a>3.使用jps查看全部hadoop相关进程</h3><p>在master上应该有一下三个进程:</p>
<pre><code>JobTracker
NameNode
SecondaryNameNode
</code></pre><p>在slave上应该有以下两个进程：</p>
<pre><code>TaskTracker
DataNode
</code></pre><p>并且可以看到core-site中的hadoop.tmp.dir属性指定的tmpdir被创建.</p>
<h3 id="4-_Hadoop_webUI_u8BBF_u95EE"><a href="#4-_Hadoop_webUI_u8BBF_u95EE" class="headerlink" title="4. Hadoop webUI访问"></a>4. Hadoop webUI访问</h3><ol>
<li><p>查看集群状态：<a href="http://masterIP:50070" target="_blank" rel="external">http://masterIP:50070</a></p>
</li>
<li><p>查看hdfs：<a href="http://mastetIP:50030" target="_blank" rel="external">http://mastetIP:50030</a></p>
</li>
</ol>
<p>各类log都可以通过webUI访问，集群工作时通过webUI进行监控也十分方便</p>
<h3 id="5-__u505C_u6B62hadoop_u5B88_u62A4_u8FDB_u7A0B"><a href="#5-__u505C_u6B62hadoop_u5B88_u62A4_u8FDB_u7A0B" class="headerlink" title="5. 停止hadoop守护进程"></a>5. 停止hadoop守护进程</h3><pre><code>stop-all.sh
</code></pre><p>这里遇到过一个问题是，基于上述的配置文件，当我二次格式化hdfs的时候失败，并且发现namenode启动不了了。<br>    查看log，二次格式化失败的原因似乎是因为当前hdfs在安全模式下,在安全模式下也无法删除hdfs上的文件。要解除安全模式:</p>
<pre><code>hadoop dfsadmin -safemode leave
</code></pre><p>重开：</p>
<pre><code>hadoop dfsadmin -safemode get
</code></pre><p>其实一般都不需要重新格式化hdfs…要重启的话只需stop.all.sh和start-all.sh切换即可。</p>
<h2 id="4-__u6D4B_u8BD5_u96C6_u7FA4"><a href="#4-__u6D4B_u8BD5_u96C6_u7FA4" class="headerlink" title="4. 测试集群"></a>4. 测试集群</h2><p>当然，如果做测试，可以直接使用从HADOOP_HOME中拷贝过来的conf，几乎不用做修改，只用修改slaves和master文件增加ip即可.<br>现测试运行自带的程序wordCount</p>
<h3 id="1-__u65B0_u5EFA_u6D4B_u8BD5_u6587_u672C_u6587_u4EF6test-txt_uFF0C_u6DFB_u52A0_u4EFB_u610F_u6587_u672C"><a href="#1-__u65B0_u5EFA_u6D4B_u8BD5_u6587_u672C_u6587_u4EF6test-txt_uFF0C_u6DFB_u52A0_u4EFB_u610F_u6587_u672C" class="headerlink" title="1. 新建测试文本文件test.txt，添加任意文本"></a>1. 新建测试文本文件test.txt，添加任意文本</h3><h3 id="2-__u628A_u8BE5_u6587_u4EF6_u653E_u5165hdfs_u4E2D"><a href="#2-__u628A_u8BE5_u6587_u4EF6_u653E_u5165hdfs_u4E2D" class="headerlink" title="2. 把该文件放入hdfs中"></a>2. 把该文件放入hdfs中</h3><p>在hdfs中创建目录input:</p>
<pre><code>hadoop fs -mkdir /user/hadoopu/input  
</code></pre><p>将本地文件系统的中的test.txt放入上述hdfs的input目录下：  </p>
<pre><code>hadoop fs -put /home/hadoopu/test.txt /user/hadoopu/input/
</code></pre><p>通过 -ls 参数可以查看：</p>
<pre><code>haddoop fs -ls /user/hadoopu/input
</code></pre><h3 id="3-_u8FD0_u884C_u6D4B_u8BD5_u7A0B_u5E8F"><a href="#3-_u8FD0_u884C_u6D4B_u8BD5_u7A0B_u5E8F" class="headerlink" title="3.运行测试程序"></a>3.运行测试程序</h3><p>切换到之前的HadoopCluster目录下运行:</p>
<pre><code>hadoop jar $HADOOP_HOME/hadoop-examples-1.0.4.jar wordcount /user/hadoopu/input/test/txt /user/hadoopu/output
</code></pre><p>后一个目录代表输出文件夹，如果运行前存在的话会报错。</p>
<p>wordcount表示要运行这个jar包中的主类wordcount，它应该是一个完全限定名，更多情况下形如pagege1.pakage2.wordcount</p>
<h2 id="conclusion"><a href="#conclusion" class="headerlink" title="conclusion"></a>conclusion</h2><p>其实做这个实验的时候真的暴露了很多问题，自己对真正hadoop的运行过程及原理还没有摸到皮毛，感觉这个只能算是个人note….whatever， no one else will see it.</p>
<p>马上要接下hz的活了，并行这一块的工程能力的恶补要提上日程了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本来想要多花时间把这份作业尽量做好，结果懒癌晚期让我在deadline前两天才开始做。。。</p>
<p>其实现在自己连门都没入，不过近段时间恐怕都没有时间继续学习hadoop了，所以下次做实验最好能尽快回忆起已学的记下这篇流水账，。<br>此外发现自己对linux仍然各种不熟，，，形成了这篇本质流水账</p>
<p>project基于hadoop 1.0.4. 属于很早的版本</p>]]>
    
    </summary>
    
      <category term="hadoop" scheme="http://potatoker.github.io/tags/hadoop/"/>
    
      <category term="linux" scheme="http://potatoker.github.io/tags/linux/"/>
    
      <category term="parellel" scheme="http://potatoker.github.io/categories/parellel/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[akka-on-android]]></title>
    <link href="http://potatoker.github.io/2015/12/24/akka-on-android/"/>
    <id>http://potatoker.github.io/2015/12/24/akka-on-android/</id>
    <published>2015-12-24T02:10:33.000Z</published>
    <updated>2015-12-24T22:27:49.802Z</updated>
    <content type="html"><![CDATA[<p>scala环境没问题了，接下来就是加入akka。<br>其实真正麻烦的在akka的库调用上。。特别是proguard rule的debug简直是摸瞎。(ಥ _ ಥ)</p>
<a id="more"></a>
<p>正常来说：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span> <span class="string">"org.scala-lang:scala-library:2.11.7"</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">"com.android.support:multidex:1.0.1"</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.typesafe.akka:akka-actor_2.11:2.3.9'</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.typesafe.akka:akka-remote_2.11:2.3.9'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把akka的库依赖加入gradle文件，完事。但事实是问题接二连三</p>
<h2 id="1-_Gradle_duplicate_file_exception"><a href="#1-_Gradle_duplicate_file_exception" class="headerlink" title="1. Gradle duplicate file exception"></a>1. Gradle duplicate file exception</h2><p>当时，具体的错误信息找不到了，不过我的解决方案是在这个<a href="https://code.google.com/p/android/issues/detail?id=61573" target="_blank" rel="external">issue</a>下面找到的,如他描述的，在两个jar中包含相同的文件。但师兄用sbt构建过相同的程序。为什么gradle会出现不得而知。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">error: duplicate files during packaging of APK .../basic/build/apk/basic-debug-unaligned<span class="class">.apk</span></span><br><span class="line">	Path <span class="keyword">in</span> archive: about<span class="class">.html</span></span><br><span class="line">	Origin <span class="number">1</span>: ...filestore/org<span class="class">.eclipse</span><span class="class">.jetty</span>/jetty-servlet/<span class="number">8.1</span>.<span class="number">8</span>.v20121106/jar/<span class="number">285</span>ea47746e9ab988a8291ea9fd6545b537e0ce9/jetty-servlet-<span class="number">8.1</span>.<span class="number">8</span><span class="class">.v20121106</span><span class="class">.jar</span></span><br><span class="line">	Origin <span class="number">2</span>: ...filestore/org<span class="class">.eclipse</span><span class="class">.jetty</span>/jetty-client/<span class="number">8.1</span>.<span class="number">8</span>.v20121106/jar/f194a5a07ada9dab48e226c4e8152d120ce1e76f/jetty-client-<span class="number">8.1</span>.<span class="number">8</span><span class="class">.v20121106</span><span class="class">.jar</span></span><br></pre></td></tr></table></figure>
<p>我的库依赖为</p>
<pre><code>&apos;com.typesafe.akka:akka-actor_2.11:2.3.9&apos;
&apos;com.typesafe.akka:akka-remote_2.11:2.3.9&apos;
</code></pre><p>类似于上述代码中的错误信息，console提示我这两个jar，包含了本地path:</p>
<pre><code>C:\Users\Ray\.ivy2\cache\com.typesafe.akka\....
</code></pre><p>然后我来到这个位置，找到上述两个jar，打开后发现确实，其中包含同名文件：reference.conf，可以判断是这个原因gradle显示duplicate file error， 然而我发现这两个文件内容并不相同。我猜想是因为同名的原因，因此我将这两个conf分别加了相应的前缀。然而仍然不可行，错误记录找不到了。但我觉得确实可能有问题，因为修改文件名应该谨慎，其他地方可能有引用。如此寻找其他的方法。</p>
<p>最终，根据上文中的issue，试出来的办法是：</p>
<ol>
<li><p>merge这两份conf文件，因为其实发现这两个配置文件确实仍然有重复的部分，而且都是类json的键值对数据组织方式，所以把其中一份所有的内容加到另一份中，并保证不重复。</p>
</li>
<li><p>在gradle中去重。<br>因为实际上我采取的策略是只使用一份conf文件，但这份conf包含之前两份的功能，但是我并没有删除任何一份，我把这份merge 过的文件加入到上述两个jar中，这样，我就成了两份<strong>真正</strong>相同文件的去重问题了。</p>
</li>
</ol>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">android</span> &#123;  </span><br><span class="line">    <span class="title">packagingOptions</span> &#123;    </span><br><span class="line">        <span class="title">pickFirst</span> <span class="string">'reference.conf'</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>于是就这样解决了这一问题。也是google了好久，当时看到这个<a href="(https://code.google.com/p/android/issues/detail?id=61573">issue</a>的时候，楼已经盖得老高了，很多描述也不是很详细， 看了好久才总结出了这个解决办法。<br>其实这个问题解决了之后，我的akka就这样真的在我的小米上跑起来了。成功使一台android 5.0设备作为一台slave完成了一项并行处理任务。</p>
<p>本该一切就这样结束了(ಥ _ ಥ)。</p>
<h2 id="2-_LinearAlloc_5MB_capacity"><a href="#2-_LinearAlloc_5MB_capacity" class="headerlink" title="2. LinearAlloc 5MB capacity"></a>2. LinearAlloc 5MB capacity</h2><p>然而，并没有什么*用，因为某原因，我仍然需要在使得该程序在g5(api 10,version 2.3.7)上跑起来。</p>
<p>果然，傲娇的g5没有跑通：</p>
<p>我出现了类似这个<a href="http://stackoverflow.com/questions/23438213/package-has-mismatched-uid-10124-on-disk-10134-in-settings" target="_blank" rel="external">SO</a>上的问题：</p>
<pre><code>Package has mismatched uid: 10124 on disk, 10134 in settings

 E/dalvikvm( 7815): LinearAlloc exceeded capacity (5242880), last=1092
</code></pre><blockquote><p>Solutions:</p>
<p>Proguard: Proguard removes unreferenced classes/methods from your app. Thus your app’s dex file size decreases. (I’ve solved my problem with proguard)  </p>
<p>Multiple Dex Files: Split your app to multiple dex files. <a href="https://www.facebook.com/notes/facebook-engineering/under-the-hood-dalvik-patch-for-facebook-for-android/10151345597798920" target="_blank" rel="external">Facebook</a> has a solution for this. Also read this <a href="http://android-developers.blogspot.se/2011/07/custom-class-loading-in-dalvik.html" target="_blank" rel="external">link</a> for managing multiple dex files.</p>
</blockquote>
<p>答案中说可以使用Multidex解决，我在想我已经按照google文档multidex方法启动了multidex了啊？但此时我们使用的g5，要重新来看待multidex以及它在低端机上可能产生的问题，再来看<a href="http://developer.android.com/tools/building/multidex.html" target="_blank" rel="external">Building Apps with Over 65K Methods</a>的multidex方法描述：<br><blockquote><p>Applications that use multidex may not start on devices that run versions of the platform earlier than Android 4.0 (API level 14) due to a Dalvik linearAlloc bug (Issue 22586). If you are targeting API levels earlier than 14, make sure to perform testing with these versions of the platform as your application can have issues at startup or when particular groups of classes are loaded. Code shrinking can reduce or possibly eliminate these potential issues.  </p>
<p>Applications using a multidex configuration that make very large memory allocation requests may crash during run time due to a Dalvik linearAlloc limit (Issue 78035). The allocation limit was increased in Android 4.0 (API level 14), but apps may still run into this limit on Android versions prior to Android 5.0 (API level 21).</p>
</blockquote></p>
<p><strong>So, the problem is Allocation Limit In old android version!</strong>，android5.0提升了很多，而g5的2.3version很小。因此解释虽然使用multidex可以在小米上跑成功而g5则不可以。</p>
<p>这个问题其实是许多需要大型依赖库app运行在某些低端机上会遇到的继method limit之后的第二个问题<a href="https://code.google.com/p/android/issues/detail?id=22586" target="_blank" rel="external">Issue 22586</a>,后文中简称为allocation limit。想要加入类似akka的大型库依赖，就必须解决这两个问题，关于这两个问题，<a href="https://ingramchen.io/blog/2014/09/prevention-of-android-dex-64k-method-size-limit.html" target="_blank" rel="external">这篇文章</a>有很好的解释分析</p>
<blockquote><p>安裝 apk 時，如果出現上面提到的兩種錯誤，你通常會看到錯誤訊息有 INSTALL_FAILED_DEXOPT 這行。dexopt 是 dex optimization 的意思，這一步驟會發生在安裝完 apk 之後，它會檢驗 .dex 裡面的指令集是不是合法，也會驗 method 的上限數。超過上限的話，app 還沒啟動就被這一步擋下，直接噴錯。dexopt 也會試著將所有 class/method 都讀進 VM 驗證，這自然會運用到 LinearAlloc buffer。如果 buffer 不夠也是直接噴了。所以程式太大的話，通通會死在 dexopt 這過程裡。</p>
<footer><strong>預防 Android Dex 64k Method Size Limit</strong><cite><a href="https://ingramchen.io/blog/2014/09/prevention-of-android-dex-64k-method-size-limit.html" target="_blank" rel="external">ingramchen.io/blog/2014/09/prevention-of-android-dex-64k-method-size-limit.html</a></cite></footer></blockquote>
<blockquote><p>apk是一个zip压缩包，dalvik每次加载apk都要从中解压出class.dex文件，加载过程还涉及到dex的classes需要的杂七杂八的依赖库的加载，真耗时间。于是Android决定优化一下这个问题，在app安装到手机之后，系统运行dexopt程序对dex进行优化，将dex的依赖库文件和一些辅助数据打包成odex文件。存放在cache/dalvik_cache目录下。保存格式为apk路径 @ apk名 @ classes.dex。这样以空间换时间大大缩短读取/加载dex文件的过程。<br>那刚才那个bug是啥问题呢，原来dexopt程序的dalvik分配一块内存来统计你的app的dex里面的classes的信息，由于classes太多方法太多超过这个linearAlloc 的限制</p>
<footer><strong>其实你不知道MultiDex到底有多坑</strong><cite><a href="http://zongwu233.github.io/the-touble-of-multidex/" target="_blank" rel="external">zongwu233.github.io/the-touble-of-multidex</a></cite></footer></blockquote>
<p>虽然使用了multidex,产生了多个dex,然而可能某个dex仍然会过大，而为了载入这个dex的class信息分配的内存有一个最大的限制。<a href="https://www.facebook.com/notes/facebook-engineering/under-the-hood-dalvik-patch-for-facebook-for-android/10151345597798920" target="_blank" rel="external">Under the Hood: Dalvik patch for Facebook for Android</a>这篇文章被引用，被解释说fb写了方案覆盖了这个容量限制，解决该问题。</p>
<p>民间出高人，除了fb的方法,还有探究这一问题的文章<a href="http://www.birbit.com/how-to-solve-linearalloc-problem/" target="_blank" rel="external">How to Solve LinearAlloc Problem</a>，以及后来我搜中文找到的<a href="http://zongwu233.github.io/the-touble-of-multidex/" target="_blank" rel="external">其实你不知道MultiDex到底有多坑</a>，总结了许多,这标题真的不是为我量身定做的吗(ಥ _ ಥ)，这篇文章解释清楚了我对于method limit 和 linearAlloc的另一些困惑。同时也在解决问题的过程中挖的非常深，包括其中的几篇引用。。。ok,ok, let’s have a break，[姚明脸]。</p>
<h3 id="Let_u2019s_try_Proguard_21"><a href="#Let_u2019s_try_Proguard_21" class="headerlink" title="Let’s try Proguard!"></a>Let’s try Proguard!</h3><p>也就是说，虽然我之前使用multidex来解决的scala库的methods limit问题，现在我重新使用proguard来解决所有因为依赖库(包括scala、akka)太大引起的问题。<strong>这里的问题包括methods limit和allocation limit</strong></p>
<p>上面SO答主说明的他采取的并最终解决了linearAlloc问题的方法，我之所以觉得他更有可能解决这个问题是因为<br>我觉得proguard方法的原理是最直接解决g5上跑较大规模依赖库app的问题，因为它十分具体的减少了构建过程的class的量，这样有效的避免了DEX 64K Methods Limit,同时也使得LinearAlloc Problem不需要考虑，事实上，在使用Multidex解决DEX 64K Methods Limit的时候，官方文档甚至提出在某些低端机上要使用proguard做配合。然而每个不同的依赖都有不同的rules，我必须找到这样一份akka rules。</p>
<p>总体的思路是：</p>
<ol>
<li>在gradle中说明启用proguard及其相关rule。</li>
<li>在网上查找akka库是否已经有现成的proguard rule文件，有则使用。</li>
<li>别人的rule并不一定完全适用，build的时候会出现class not found的问题</li>
<li>根据错误提示，增加keep 规则</li>
<li>重复3,4直至build和run的时候都没有classNotFound的问题</li>
</ol>
<p>这个东西当我第一次看到他的<a href="https://stuff.mit.edu/afs/sipb/project/android/sdk/android-sdk-linux/tools/proguard/docs/index.html#manual/introduction.html" target="_blank" rel="external">文档</a>的时候，就方了，这种朴素的markdown风格加上瀑布一般的排版。。。看不下去。。。总之原理基本上是，根据控制台输出的错误信息，一般是，方法或者类丢失，说明proguard丢弃了这个方法或类，那么在rule文件里把有完全限定名的类使用keep语句手动保留，就可以了。比较典型的有下面两种：  </p>
<pre><code>如果Build过程提示classNotFound或者methodNotFound就直接keep 
</code></pre><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-keep class akka.actor.LocalActorRefProvider<span class="variable">$Guardian</span>&#123;</span><br><span class="line">  *;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果告诉你类似<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.RuntimeException: Unable to <span class="operator"><span class="keyword">start</span> activity ComponentInfo&#123;com.myapp/com.myapp.MyActivity&#125;: <span class="keyword">java</span>.lang.NoSuchMethodException: &lt;init&gt; [<span class="keyword">interface</span> com.typesafe.config.Config, <span class="keyword">interface</span> akka.<span class="keyword">event</span>.LoggingAdapter, <span class="keyword">interface</span> <span class="keyword">java</span>.util.<span class="keyword">concurrent</span>.ThreadFactory]</span></span><br></pre></td></tr></table></figure></p>
<p>则用：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">keepclasseswithmembers <span class="class"><span class="keyword">class</span> * &#123;</span></span><br><span class="line"></span>    public &lt;init&gt;(com.typesafe.config.Config, akka.event.LoggingAdapter, java.util.concurrent.ThreadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p>
<p>这两招屡试不爽。。虽然proguard还有许多其他keep方式。。。但实在不想去看瀑布了。。</p>
<p>在这个过程中数度想要放弃<br><strong>BUT</strong>确实到最后没有classNotFound的问题了，build也成功了，然而新问题是：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">11</span>:<span class="number">27</span>:<span class="number">42.149</span>] [WorkerSystem-akka.remote.default-remote-dispatcher-<span class="number">6</span>] [akka.tcp:<span class="regexp">//</span>WorkerSystem<span class="variable">@192</span>.<span class="number">168.1</span>.<span class="number">108</span>:<span class="number">2555</span>/<span class="keyword">system</span>/endpointManager/reliableEndpointWriter-akka.tcp<span class="variable">%3A</span><span class="variable">%2F</span><span class="variable">%2FParallelHOSVD</span><span class="variable">%40192</span>.<span class="number">168.1</span>.<span class="number">102</span><span class="variable">%3A2552</span>-<span class="number">0</span>] Association with remote <span class="keyword">system</span> [akka.tcp:<span class="regexp">//</span>ParallelHOSVD<span class="variable">@192</span>.<span class="number">168.1</span>.<span class="number">102</span>:<span class="number">2552</span>] has failed, address is now gated <span class="keyword">for</span> [<span class="number">5000</span>] ms. Reason is: [exception during creation].</span><br></pre></td></tr></table></figure>
<p>然后我用小米同样试着跑了一下，发现一样的问题，所以是我前面的build过程仍然有问题。然而现在已知的错误信息只有这个，并且似乎只是简单地在阐述连接失败，并没有为何失败的信息。从这个节点已经查不下去了。</p>
<p>事实上，网上确实已有不少akka proguard，<a href="https://github.com/sbt/sbt-proguard/blob/master/src/sbt-test/proguard/akka/project/SampleBuild.scala" target="_blank" rel="external">sbt-proguard</a>，<a href="https://groups.google.com/forum/#!topic/scala-on-android/JwMQCtC2zCs" target="_blank" rel="external">Akka, Android, Proguard</a>,甚至已有和我同样在这样以身试坑的人在：<a href="http://spin.atomicobject.com/2013/06/20/akka-scala-on-android/" target="_blank" rel="external">Getting Scala with Akka Actors Working on Android</a>.</p>
<blockquote><p>Once the code was running, I would wait for it to crash with a runtime exception, which would tell me what class was missing.<br>I could then update my ProGuard config, rinse, and repeat.</p>
</blockquote>   
<h3 id="proguard_conclusion"><a href="#proguard_conclusion" class="headerlink" title="proguard conclusion"></a>proguard conclusion</h3><p>该保留哪些方法哪些class靠人工写一份没有漏洞的rule太难，关于第三方库proguard rule看到过这样的阐述:</p>
<blockquote><p>Many problems with ProGuard stem from the inclusion of third-party libraries in your project.<br>the first step in avoiding such errors is to consult the documentation of each third-party library and follow any instructions for deployment with ProGuard.<br>If the documentation mentions nothing about ProGuard, but the library is open source, then there is no point to obfuscating its code from a security standpoint anyway.</p>
<footer><strong>A Conservative Guide to ProGuard for Android</strong><cite><a href="http://omgitsmgp.com/2013/09/09/a-conservative-guide-to-proguard-for-android/" target="_blank" rel="external">omgitsmgp.com/2013/09/09/a-conservative-guide-to-proguard-for-android</a></cite></footer></blockquote>
<h2 id="Still_using_multidex"><a href="#Still_using_multidex" class="headerlink" title="Still using multidex"></a>Still using multidex</h2><p>如果使用Multidex方法，则要解决<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Package has mismatched uid: <span class="number">10124</span> <span class="function_start"><span class="keyword">on</span></span> disk, <span class="number">10134</span> <span class="keyword">in</span> settings   </span><br><span class="line">E/dalvikvm( <span class="number">7815</span>): LinearAlloc exceeded capacity (<span class="number">5242880</span>), <span class="keyword">last</span>=<span class="number">1092</span></span><br></pre></td></tr></table></figure></p>
<p>根据之前的总结其实是Android早期版本的Dalvik linearAlloc bug。。其实当我读完<a href="http://zongwu233.github.io/the-touble-of-multidex/" target="_blank" rel="external">其实你不知道MultiDex到底有多坑</a>。远不止这个bug需要解决。。。这个坑。。等我吃点好的再跳(ಥ _ ಥ).</p>
<h2 id="conclusion"><a href="#conclusion" class="headerlink" title="conclusion"></a>conclusion</h2><p>所以其实这整个过程，如果不看g5，已经做到了使用scala写android程序，以及在Android5.0设备上使用akka，使移动设备成为一个并行系统的slave进行工作。</p>
<p>至于g5的结论就是使用proguard可以解决scala库依赖的问题，然而当我再添加akka时，proguard我目前只会采取摸瞎的方式写rules，操作的不确定性极大，如果不使用proguard,使用multidex解决<code>scala&amp;akka-actor&amp;akka-remote</code>这种规模的依赖库依赖问题仍有<strong>Dalvik linearAlloc bug</strong>待解决。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>scala环境没问题了，接下来就是加入akka。<br>其实真正麻烦的在akka的库调用上。。特别是proguard rule的debug简直是摸瞎。(ಥ _ ಥ)</p>]]>
    
    </summary>
    
      <category term="akka" scheme="http://potatoker.github.io/tags/akka/"/>
    
      <category term="android" scheme="http://potatoker.github.io/tags/android/"/>
    
      <category term="build" scheme="http://potatoker.github.io/tags/build/"/>
    
      <category term="parallel" scheme="http://potatoker.github.io/tags/parallel/"/>
    
      <category term="android" scheme="http://potatoker.github.io/categories/android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[scala on android]]></title>
    <link href="http://potatoker.github.io/2015/12/23/scala-on-android/"/>
    <id>http://potatoker.github.io/2015/12/23/scala-on-android/</id>
    <published>2015-12-23T07:11:30.000Z</published>
    <updated>2015-12-24T22:14:04.563Z</updated>
    <content type="html"><![CDATA[<p>今天大概要宣布第一条路走不通了。</p>
<p>感觉还是有必要把这条路重新理一下。。。毕竟并不是什么效果都没有看到。</p>
<p>任务：在安卓手机上实现akka remote，我也不知道做这件事情到底有什么意义= =</p>
<p>现有条件： </p>
<ol>
<li>一个需要akka跑的scala分布式程序。</li>
<li>丧心病狂的来了，由于某种更加扭曲的实验方式的限制，最终实验必须要在一台g5上跑起来。</li>
</ol>
<p>恩，先压抑住吐槽</p>
<a id="more"></a>
<h1 id="scala_on_android"><a href="#scala_on_android" class="headerlink" title="scala on android"></a>scala on android</h1><p> 经过搜索之后，发现在安卓平台上跑scala并不是什么新鲜事了，scala作为一门基于java虚拟机的语言，同样第一步需要预编译成class文件，然后打包成apk安装到android上，原理上是完全没有问题的。</p>
<p>不过当时遇到的问题是，一般scala使用的build tool 是sbt，而我目前使用的IDE android studio使用的是gradle. 这样记得当时google出来的scala on android的一些插件或者套路基本根据这两种build tool来的。我也不知道该使用哪一种，因为实际上两种我都并没有很了解，似乎走了不少弯路。  </p>
<p>不过最终，让我跑通的是：<a href="https://github.com/saturday06/gradle-android-scala-plugin" target="_blank" rel="external">基于gradle的</a>，毕竟这是android studio自带的build tool, 配置起来可能会方便一点。</p>
<p>这里遇到一个问题是<a href="https://developer.android.com/tools/building/multidex.html" target="_blank" rel="external">DEX 64K Methods Limit</a>.当依赖的库太多的时候(这个scala语言库本身还是比较大)，毕竟这些Jar包都要被一起build成一个dex文件，而默认一个apk只包含一个dex文件。 android的build机制对这样的一个库的容量有所限制.：</p>
<blockquote><p>As the Android platform has continued to grow, so has the size of Android apps. When your application and the libraries it references reach a certain size, you encounter build errors that indicate your app has reached a limit of the Android app build architecture. Earlier versions of the build system report this error as follows:</p>
<pre><code>Conversion to Dalvik format failed:
Unable to execute dex: method ID not in [0, 0xffff]: 65536
</code></pre><p>More recent versions of the Android build system display a different error, which is an indication of the same problem:</p>
<pre><code>trouble writing output:
Too many field references: 131000; max is 65536.
You may try using --multi-dex option.
</code></pre></blockquote>
<p>其实这个问题在解决scala库依赖的时候根本不需要我操心。。因为我只用在作者已经配置好的<a href="https://github.com/saturday06/gradle-android-scala-plugin/tree/master/sample/simple" target="_blank" rel="external">sample</a>上继续写程序就可以了。</p>
<h3 id="1-_use_proguard"><a href="#1-_use_proguard" class="headerlink" title="1. use proguard."></a>1. use proguard.</h3><p>android devloper上有简单地概念介绍：</p>
<blockquote><p>The ProGuard tool shrinks, optimizes, and obfuscates your code by removing unused code and renaming classes, fields, and methods with semantically obscure names. The result is a smaller sized .apk file that is more difficult to reverse engineer.</p>
<footer><strong>ProGuard</strong><cite><a href="http://developer.android.com/tools/help/proguard.html" target="_blank" rel="external">developer.android.com/tools/help/proguard.html</a></cite></footer></blockquote>
<p>这东西有两个作用，一个是减小apk的大小，一个是对方法名进行混淆。我需要用到他的第一个作用，思路就是引用的库中，很多方法其实根本用不到，所以proguard就会帮助build tool把引用到的那一部分加入编译，这样就不会使dex文件过大。那么他是怎么判断哪些方法该被加入编译，哪些是没用的呢，这东西还没有那么智能。。需要一份rules来规定哪些方法和类是需要保存的，虽然sdk tool自带一份默认的rules，但是！一般情况还是需要debug一下，然后手动修改rules文件。如果是第三方的jar包，那就更没得跑了。</p>
<p>其实在使用scala lib的时候并不需要这一步，因为之前提到过，直接使用作者已经配置好的<a href="https://github.com/saturday06/gradle-android-scala-plugin/tree/master/sample/simple" target="_blank" rel="external">sample</a>就可以了，不过这个sample使用的是第二种方法。但是如果想要使用progurad来解决这个问题也可以在网上找到现成的scala库的<a href="https://github.com/pocorall/hello-scaloid-gradle/blob/master/proguard-rules.txt" target="_blank" rel="external">proguard rule</a>,这个方法我也使用过，也可以成功跑通scala.</p>
<p>scala这一块已经解决，然而。。akka似乎并没有提供这样一份东西。。详细的内容在后一篇。</p>
<h3 id="2-_Use_MultiDex"><a href="#2-_Use_MultiDex" class="headerlink" title="2. Use MultiDex"></a>2. Use MultiDex</h3><p>事实上我使用的作者的sample 并没有使用proguard方法，而是使用 multidex。<br>解决思路就是，以前一个apk只有一个dex包，dex又有大小限制，那么我就吧class分成多个dex打包，使用不同dex中的class的时候采取某种调用机制。这样就不会超过这个限制。</p>
<p>官方解释：<br><blockquote><p>Versions of the platform prior to Android 5.0 use the Dalvik runtime for executing app code. By default, Dalvik limits apps to a single classes.dex bytecode file per APK. In order to get around this limitation, you can use the multidex support library, which becomes part of the primary DEX file of your app and then manages access to the additional DEX files and the code they contain. </p>
<p>Android 5.0 and higher uses a runtime called ART which natively supports loading multiple dex files from application APK files.</p>
</blockquote></p>
<p>其实主要是在gradle的build文件中添加multidex方法的依赖库，然后修改一些关联的配置<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">  <span class="keyword">compile</span> <span class="string">'com.android.support:multidex:1.0.0'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  </p>
<p>详细的内容太仍然在<a href="https://developer.android.com/tools/building/multidex.html#mdex-gradle" target="_blank" rel="external">Configuring Your App for Multidex with Gradle</a> 。</p>
<p><strong>这里有非常重要的一点是multidex方法不能直接适用于低端机，我使用的是android 5.0device，在akka-on-andorid中我使用了multidex试图解决大型库依赖的问题，但会产生另外的问题。但是Android 2.3.7使用proguard之后是可以跑这个scala库的。</strong></p>
<p>题外话：</p>
<p>想起毕设的时候就用到过dex，不过仍然是懵懵懂懂，又是kd移动分布式任务处理。。。通过用sdk tool可以把jar转换成dex, 这样一个dex就是分块任务，从而方便任务的分发与调用。看到Multidex lib的机制就想到了这么一件事。</p>
<h3 id="in_the_end"><a href="#in_the_end" class="headerlink" title="in the end"></a>in the end</h3><p>总结一下，在android上使用scala:</p>
<ol>
<li><p>根据IDE下载scala语言的parse插件，我在android studio中使用的是<a href="http://www.jetbrains.net/confluence/display/SCA/Scala+Plugin+for+IntelliJ+IDEA" target="_blank" rel="external">这款</a>。这样IDE可以识别scala.</p>
</li>
<li><p>使用这款支持scala编译的<a href="https://github.com/saturday06/gradle-android-scala-plugin" target="_blank" rel="external">插件</a>，并根据其read文件来解决可能遇到的<a href="https://developer.android.com/tools/building/multidex.html" target="_blank" rel="external">DEX 64K Methods Limit</a>问题。<br>有两个解决方法：如果使用multidex，参考<a href="https://developer.android.com/tools/building/multidex.html#mdex-gradle" target="_blank" rel="external">Configuring Your App for Multidex with Gradle</a>，步骤并不多。甚至你可以直接使用该<a href="https://github.com/saturday06/gradle-android-scala-plugin/tree/master/sample/simple" target="_blank" rel="external">sample</a>的build配置，在此基础上写程序即可；如果使用proguard，先上网搜索该库的proguard文件，常常会有人已经写出来了，这里<a href="https://github.com/pocorall/hello-scaloid-gradle/blob/master/proguard-rules.txt" target="_blank" rel="external">hello-scaloid-gradle</a>就做了提供。</p>
</li>
<li><p>使用scala来写android app~<br>可以使用一些框架，比如<a href="https://github.com/pocorall/scaloid" target="_blank" rel="external">scaloid</a></p>
</li>
</ol>
<blockquote><p>Scaloid is a library that simplifies your Android code.<br>It makes your code easy to understand and maintain by leveraging Scala language.</p>
</blockquote>
<p><img src="https://camo.githubusercontent.com/72417659473b911df7f1bd03359de67685783ae7/687474703a2f2f6f2d6e322e636f6d2f766572626f736553696d706c652e706e67" alt=""></p>
<p>如上图所示， 确实，即使利用scala多范式语言的特性，就可以对比java写出同样功能但清爽许多的code。但是使用scala无法忽视的一点是，加入了scala语言库这个容量巨大的依赖(或者是因为太复杂的类继承关系)<a href="https://code.google.com/p/android/issues/detail?id=22586" target="_blank" rel="external">issue 22586</a>中讨论的就是sacala引起的LinearAlloc exceeded问题。<br><blockquote><p>由於 Android dex 的種種限制，造成 method 數量有上限的問題，再加上第三方 library 揮霍無度，使得即使你的 App 還很小，卻不小心會撞上這個 64k method 數限制。建議：</p>
<ol>
<li>慎選第三方 library，最好採用前先用 dex-method-count 度量一下</li>
<li>scala, groovy 這類非原生的開發語言想都不要想，它們只會帶來更多的問題。用非 Java 語言開發可以，但是僅限於 NDK</li>
<li>要替 Google play service 瘦身</li>
<li>square 出品的 library 都很適合 Android 使用</li>
<li>Android 2.3 的可用 method 數更少，約 56000，不過這只要 proguard 後達成即可。</li>
</ol>
<footer><strong>預防 Android Dex 64k Method Size Limit</strong><cite><a href="https://ingramchen.io/blog/2014/09/prevention-of-android-dex-64k-method-size-limit.html" target="_blank" rel="external">ingramchen.io/blog/2014/09/prevention-of-android-dex-64k-method-size-limit.html</a></cite></footer></blockquote><br>如果你只是想要用android5.0 以上的device玩玩scala，大概都不会出现问题，但是，用这个写app的话，没办法保证会在什么样的千奇百怪的android device上出现问题。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天大概要宣布第一条路走不通了。</p>
<p>感觉还是有必要把这条路重新理一下。。。毕竟并不是什么效果都没有看到。</p>
<p>任务：在安卓手机上实现akka remote，我也不知道做这件事情到底有什么意义= =</p>
<p>现有条件： </p>
<ol>
<li>一个需要akka跑的scala分布式程序。</li>
<li>丧心病狂的来了，由于某种更加扭曲的实验方式的限制，最终实验必须要在一台g5上跑起来。</li>
</ol>
<p>恩，先压抑住吐槽</p>]]>
    
    </summary>
    
      <category term="android" scheme="http://potatoker.github.io/tags/android/"/>
    
      <category term="proguard" scheme="http://potatoker.github.io/tags/proguard/"/>
    
      <category term="scala" scheme="http://potatoker.github.io/tags/scala/"/>
    
      <category term="android" scheme="http://potatoker.github.io/categories/android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[cat]]></title>
    <link href="http://potatoker.github.io/2015/12/23/cat/"/>
    <id>http://potatoker.github.io/2015/12/23/cat/</id>
    <published>2015-12-23T06:33:28.000Z</published>
    <updated>2015-12-23T06:33:28.503Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[learn pyspider]]></title>
    <link href="http://potatoker.github.io/2015/12/20/learn-pyspider/"/>
    <id>http://potatoker.github.io/2015/12/20/learn-pyspider/</id>
    <published>2015-12-20T14:34:32.000Z</published>
    <updated>2015-12-22T05:55:22.499Z</updated>
    <content type="html"><![CDATA[<p>虽然知道当时实验室的活以及随之到来的各种考试已经占满了时间表，但是仅仅因为我自己很想做，还是接下来了。</p>
<h1 id="u5FC3_u8DEF_u5386_u7A0B"><a href="#u5FC3_u8DEF_u5386_u7A0B" class="headerlink" title="心路历程"></a>心路历程</h1><p>大概了解了爬虫的情况之后，觉得还是用框架比较好。<br>当时的需求是：</p>
<ol>
<li>爬的数据量要比较大，当时他们甚至提出多买几台服务器的提议。</li>
<li>需要的信息很多是实时刷新，这也是需要这个审核发布系统的原因，可是随时尽快的得到最新的爬虫数据。</li>
<li>希望可以方便的添加爬虫，也便于这个部分给非技术人员的交接。</li>
</ol>
<a id="more"></a>
<p>然后大概了解了当前的爬虫技术的情况，首先进入视野的当然是scrapy。确实，scrapy非常容易上手，几个组件的工作流程清晰。不过我当时马上遇到了要解析js请求的问题。对于不需要js渲染的网站，当时很快成功了，面对需要渲染的网站：主要办法</p>
<ol>
<li>手动模拟请求方式</li>
<li>配合轻型浏览器作为中间件来渲染网页</li>
</ol>
<p>不过看过了某家网站的请求，发现似乎其request是加密的，每次js request是不一样的，因此觉得第一个办法打了折，并且关于渲染时间和人工分析时间的trade off，目前情况，我还是觉得后者比较昂贵。</p>
<p>至于第二种办法，我找到了这个组件： <a href="http://blog.scrapinghub.com/2015/03/02/handling-javascript-in-scrapy-with-splash/" target="_blank" rel="external">Splash</a>,<a href="http://splash.readthedocs.org/en/stable/" target="_blank" rel="external">文档</a>，其实发现splash的定制化很高，但是文档也很长。没耐心看的时候有点头疼，中间我在调试的时候发现了另外一个爬虫框架：<a href="http://docs.pyspider.org/en/latest/Working-with-Results/" target="_blank" rel="external">pyspider</a>，这是它的描述：</p>
  <blockquote><ul>
<li>Write script in Python  </li>
<li>Powerful WebUI with script editor, task monitor, project manager and result viewer  </li>
<li>MySQL, MongoDB, Redis, SQLite, PostgreSQL with SQLAlchemy as database backend</li>
<li>RabbitMQ, Beanstalk, Redis and Kombu as message queue</li>
<li>Task priority, retry, periodical, recrawl by age, etc…</li>
<li>Distributed architecture, Crawl Javascript pages, Python 2&amp;3, etc…</li>
</ul>
</blockquote>
<p>完全符合需求，更重要的是，文档中也直接给出当时比较头疼的js渲染问题例子，感觉比较适合自己小白的身份。而且文档一点也不长，解释很清楚，所以立马上手试验，对了，关键是有web端控制台，简直就是小白的利器。考虑到当时最主要的解析js的问题，同样目钱的需求是能立刻使功能实现，另外phantomjs也允许做出进一步的渲染需求，所以马上就转手Pyspider了。</p>
<p>以一个小白的身份感受比较深的是这几点好处：</p>
<ol>
<li>组件结构清晰，适应分布式的处理方式，因此也容易根据各个组建的状态分析问题。</li>
<li>控制台友好，方便在其他终端查看服务器上的爬虫状态，更重要的是，在其他终端就可以很方便的进行调试。</li>
<li>组件的配置非常灵活，可以适应不同的爬虫规模。</li>
</ol>
<p>特别是自己感受的前两点，<strong>非常方便找bug和分析问题</strong>，一直觉得调试方便时使用轮子的最重要的一点.<br>另外这个框架是北邮的一位同学写的，在group里是有问必答。感谢轮子主。。。还有比这一点更适合小白的吗<em>(:зゝ∠)</em></p>
<h1 id="u5177_u4F53_u4F7F_u7528"><a href="#u5177_u4F53_u4F7F_u7528" class="headerlink" title="具体使用"></a>具体使用</h1><h2 id="u5B89_u88C5_u8FC7_u7A0B"><a href="#u5B89_u88C5_u8FC7_u7A0B" class="headerlink" title="安装过程"></a>安装过程</h2><p>除了官方文档，参考这位同学的<a href="https://imlonghao.com/9.html" target="_blank" rel="external">博文</a>，这位博主的<a href="https://imlonghao.com/10.html" target="_blank" rel="external">轻松组建分布式 pyspider 集群</a>也是很好的参考。</p>
<h2 id="u4F7F_u7528"><a href="#u4F7F_u7528" class="headerlink" title="使用"></a>使用</h2><p>作者的文档比较清晰，这里有几处花时间较多的点：</p>
<ol>
<li><p>phamtomjs挂掉  </p>
<p>crawl rate这里，作者提到了<a href="http://en.wikipedia.org/wiki/Token_bucket" target="_blank" rel="external">token_bucket</a>，之前有时候会遇到phantomjs挂掉的情况，实验过后发现应该适合crawl rate的设置有关。遇到phamtomjs挂掉的问题，我现在的解决办法是：</p>
</li>
</ol>
<ul>
<li>设置crawl rate变小，默认1/3,我会改成0.5/3，</li>
<li>在不同的端口多开几个phantomjs的process和对应的 fetcher的process</li>
</ul>
<p>其实关于速率这个问题，我还没有仔细的研究过该怎么找到最好的适应不同爬虫规模的那个point，作者也提供了爬虫平均速率在Webui的展示，但是赶着完成其他部分。以后不同规模和环境的爬虫跑起来以后，可能这个问题还是需要搞清楚。</p>
<ol>
<li>重写result处理方法</li>
</ol>
<p>在框架中的result默认处理方式是将所有结构化信息打包成了一个jsonobject存储在了默认以project为名的表中。并且框架不提供关于进一步处理result的接口，这样的话，需要重写result处理这部分的程序。重写on_result方法（刚方法是处理前面爬虫组件传递的result的回调方法）。默认是project, taskid等此类task信息加上一个result jsonobject作为插入数据库的feild，这里，我需要把result json拆分成单独的field插入到指定的表中。重写的<a href="https://github.com/potatoker/pyspider-files" target="_blank" rel="external">my_result_worker</a>这个类将被作为参数指定执行result_worker组件。把这两个文件放到pyspider的根目录下即可。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>虽然知道当时实验室的活以及随之到来的各种考试已经占满了时间表，但是仅仅因为我自己很想做，还是接下来了。</p>
<h1 id="u5FC3_u8DEF_u5386_u7A0B"><a href="#u5FC3_u8DEF_u5386_u7A0B" class="headerlink" title="心路历程"></a>心路历程</h1><p>大概了解了爬虫的情况之后，觉得还是用框架比较好。<br>当时的需求是：</p>
<ol>
<li>爬的数据量要比较大，当时他们甚至提出多买几台服务器的提议。</li>
<li>需要的信息很多是实时刷新，这也是需要这个审核发布系统的原因，可是随时尽快的得到最新的爬虫数据。</li>
<li>希望可以方便的添加爬虫，也便于这个部分给非技术人员的交接。</li>
</ol>]]>
    
    </summary>
    
      <category term="crawler" scheme="http://potatoker.github.io/tags/crawler/"/>
    
      <category term="python" scheme="http://potatoker.github.io/tags/python/"/>
    
      <category term="general tech" scheme="http://potatoker.github.io/categories/general-tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[json使用总结]]></title>
    <link href="http://potatoker.github.io/2015/12/20/json%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://potatoker.github.io/2015/12/20/json使用总结/</id>
    <published>2015-12-20T12:38:30.000Z</published>
    <updated>2016-01-30T12:38:11.039Z</updated>
    <content type="html"><![CDATA[<p>写爬虫的时候真的发现json很好用，作为一种序列化机制。。。恐怕没有更好理解的了。</p>
<p>这里我的数据经历了：</p>
<p><strong>网站–&gt;python爬虫–&gt;mysql数据库&lt;–&gt;php程序&lt;–&gt;java(安卓app)</strong></p>
 <a id="more"></a> 
<p>这里，把上次项目中使用的上述整个数据流的一套方案列在这里，方便今后查阅。</p>
<p>其中：</p>
<h1 id="1-_python_u5230mysql"><a href="#1-_python_u5230mysql" class="headerlink" title="1. python到mysql"></a>1. python到mysql</h1><p> 在爬虫中，将response中需要的数据整合成dict例如：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">         <span class="string">"url"</span>: response.url,</span><br><span class="line">         <span class="string">"title"</span>: response.doc(<span class="string">'.article_title'</span>).text(),</span><br><span class="line">         <span class="string">"price"</span>: response.doc(<span class="string">'.article_title span'</span>).text(),</span><br><span class="line">         <span class="string">"sale_desc"</span>: response.doc(<span class="string">'[itemprop="description"]:first-child'</span>).text(),</span><br><span class="line">         <span class="string">"product_desc"</span>: response.doc(<span class="string">'.wiki-box+.inner-block p:first-child'</span>).text(),</span><br><span class="line"><span class="string">"imglist"</span>: imglist</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该dict将被以**arg的形式传递给数据库操作函数，从而将dict中的item一一对应插入到数据库的表的field中。这其中注意到imglist是一个列表，其他类型都是text(感觉还没有从python implicit声明的习惯中适应)。在pyspider源码中，数据库操作传入的参数是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">obj = &#123;</span><br><span class="line">         <span class="string">'taskid'</span>: taskid,</span><br><span class="line">         <span class="string">'url'</span>: url,</span><br><span class="line">         <span class="string">'result'</span>: result,</span><br><span class="line">         <span class="string">'updatetime'</span>: time.time(),</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> self._replace(tablename, **self._stringify(obj))</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">_stringify</span><span class="params">(self, data)</span>:</span></span><br><span class="line">     <span class="keyword">if</span> <span class="string">'result'</span> <span class="keyword">in</span> data:</span><br><span class="line">         data[<span class="string">'result'</span>] = json.dumps(data[<span class="string">'result'</span>])</span><br><span class="line">     <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>
<p>如果dict中有除字符串以外的数据类型也需要进行“字符串化”，就是这里的_stringfy()函数,其实就是进行json格式的转换。所以同理，在重写的result_worker中也应该吧imglist这个python中的list转换为json,在放入dict传递给数据库操作函数:</p>
<pre><code>imgjson = json.dumps(imgList)
</code></pre><p>这样return的dict就可以放心交给result_worker，其实json化这一步也可以放在<a href="https://github.com/potatoker/pyspider-files/blob/master/result_worker/my_result_worker.py" target="_blank" rel="external">my_result_worker</a>中，因为在on_result方法中才会把整个dict传给数据库操作类SQL。</p>
<p>所以总结的话，常常会用到把python中的数据映射到数据库中，由于python的dict和**args参数形式十分好用，所以只用把需要的数据库field组织成dict，这个dict的各个值都是字符串，如果有数据不是的话就将其jsondump然后传给数据库操作函数就可以了。把pyspider的源码抄过来：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">replace</span><span class="params">(self,tablename=None,**values)</span>:</span></span><br><span class="line">   <span class="keyword">if</span> SQL.connection == <span class="string">''</span>:</span><br><span class="line">       <span class="keyword">print</span> <span class="string">"Please connect first"</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">   tablename = self.escape(tablename )</span><br><span class="line">   <span class="keyword">if</span> values:</span><br><span class="line">       _keys = <span class="string">", "</span>.join(self.escape(k) <span class="keyword">for</span> k <span class="keyword">in</span> values)</span><br><span class="line">       _values = <span class="string">", "</span>.join([self.placeholder, ] * len(values))</span><br><span class="line">       sql_query = <span class="string">"REPLACE INTO %s (%s) VALUES (%s)"</span> % (tablename, _keys, _values)</span><br><span class="line">   <span class="keyword">else</span>:</span><br><span class="line">       sql_query = <span class="string">"REPLACE INTO %s DEFAULT VALUES"</span> % tablename</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   cur = SQL.connection.cursor()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span>:</span><br><span class="line">       <span class="keyword">if</span> values:</span><br><span class="line">           cur.execute(sql_query, list(itervalues(values)))</span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">           cur.execute(sql_query)</span><br><span class="line"></span><br><span class="line">       SQL.connection.commit()</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">   <span class="keyword">except</span> mysql.connector.Error <span class="keyword">as</span> err:</span><br><span class="line">       <span class="keyword">print</span> (<span class="string">"An error occured: &#123;&#125;"</span>.format(err))</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<p>这种程序数据到数据库数据的映射简直是万金油啊，不要太好用。完整的SQL文件在<a href="https://github.com/potatoker/pyspider-files/blob/master/result_worker/mymysql.py" target="_blank" rel="external">这里</a>。</p>
<p>在数据库中，可以看到在数据库中imglist的形式是[‘aa’,’bb’]，当然是字符串，但是在今后的额decode的时候来看，这是一个jsonArray.完整的映射表如下:</p>
<p>  <img src="http://images.cnblogs.com/cnblogs_com/coser/201112/201112141621136287.png" alt=""></p>
<p>在源码中result作为一个dict被jsondump()之后插入数据库的field，在数据库中显示<code>{&quot;name&quot;:&quot;dd&quot;,&quot;hobby&quot;:&quot;aa&quot;}</code>,是一个jsonobject.</p>
<h1 id="2-_mysql-_26gt_3Bphp"><a href="#2-_mysql-_26gt_3Bphp" class="headerlink" title="2. mysql-&gt;php"></a>2. mysql-&gt;php</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="variable">$row</span>=mysql_fetch_array(<span class="variable">$result</span>,MYSQL_ASSOC))</span><br><span class="line">&#123;</span><br><span class="line">  	<span class="keyword">echo</span> urldecode(json_encode(<span class="variable">$row</span>));</span><br><span class="line">  	<span class="keyword">echo</span> <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>游标中的一个row被取下来之后，转换成json然后echo出去。</p>
<h1 id="3-_php-_26gt_3Bjava"><a href="#3-_php-_26gt_3Bjava" class="headerlink" title="3. php-&gt;java"></a>3. php-&gt;java</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">JSONObject json = <span class="keyword">new</span> JSONObject(result);</span><br><span class="line">details = json.getString(<span class="string">"details"</span>);</span><br><span class="line">JSONArray images = json.getJSONArray(<span class="string">"imglist"</span>);<span class="comment">//imglist代表的项是一个list</span></span><br><span class="line"> 	 <span class="comment">//把imglist里的网址(string 类型)传递给了java array</span></span><br><span class="line">String[] banImages = <span class="keyword">new</span> String[images.length()];						</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; images.length(); i++)&#123;</span><br><span class="line">	String image = images.getString(i);</span><br><span class="line">	banImages[i] = image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>php echo的字节流进入socket的inputstream，这个字节流的一行就是sql执行的row，通过readline就可以取出这一行，这一行在php里经过json_encode，所以在java这边作为一个JSONObject，然后进行解析，通过get函数来取出每一个field，这样就最终得到需要的粒化的数据了。</p>
<h1 id="4-_java-_26gt_3Bphp"><a href="#4-_java-_26gt_3Bphp" class="headerlink" title="4. java-&gt;php"></a>4. java-&gt;php</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JSONObject checkState = <span class="keyword">new</span> JSONObject();</span><br><span class="line"></span><br><span class="line">checkState.put(<span class="string">"name"</span>, <span class="string">"Raymond"</span>);</span><br><span class="line"></span><br><span class="line">JsonArray keptIds = <span class="keyword">new</span> JsonArray(keptIdList)<span class="comment">//keptIdList是一个java List类型</span></span><br><span class="line"></span><br><span class="line">checkState.put(keptIds.toString());</span><br></pre></td></tr></table></figure>
<p>把一个java对象的各个变量put到这个JSONObject中就可以了。</p>
<p>发送过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String uploadString = checkState.toString()<span class="comment">//这里checkstate被转换为String,将被通过outputstream传递给server上的php，</span></span><br><span class="line"></span><br><span class="line">String content = URLEncoder.encode(<span class="string">"checkstate"</span>, <span class="string">"UTF-8"</span>) + <span class="string">"="</span></span><br><span class="line">							+ URLEncoder.encode(uploadString ,<span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">out.writeBytes(content);</span><br></pre></td></tr></table></figure>
<p>整个传输的例子还有诸如<a href="http://stackoverflow.com/questions/19627524/post-data-in-json-format-to-php-script-with-java" target="_blank" rel="external">这里</a></p>
<h1 id="5_php-_26gt_3Bmysql"><a href="#5_php-_26gt_3Bmysql" class="headerlink" title="5 php-&gt;mysql"></a>5 php-&gt;mysql</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$checkstate</span> = <span class="variable">$_POST</span>[<span class="string">'checkstate'</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable">$checkobj</span> =  json_decode(<span class="variable">$checkstate</span>，<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$sql</span> = <span class="string">"insert into footable(kept_ids, name) values("</span>.<span class="string">"'$checkstate['keptIds'],"</span><span class="string">',".'</span> <span class="variable">$checkstate</span>[<span class="string">'name'</span>]).<span class="string">'";";</span></span><br></pre></td></tr></table></figure>
<p>通过<a href="http://php.net/manual/en/function.json-decode.php" target="_blank" rel="external">json_decode</a>把从post变量里得到的jsonobj转换成php的关联数组(第二个参数true就是指定成关联数组返回)，这样就可以以键值对的方式获取jsonobj里的数据了。</p>
<h1 id="6_About_the_List"><a href="#6_About_the_List" class="headerlink" title="6 About the List"></a>6 About the List</h1><p>可以发现一个细节是</p>
<pre><code>checkState.put(keptIds.toString());//keptIds类型为JSONArray
</code></pre><p>这里，我之前犯的一个错误是，在mysql中keptIds的数据类型是varchar型（或mediumbob），并且php中的Insert语句中，从checkob中取值仍然如<strong>5</strong>中代码一样。<br>但我使用：</p>
<pre><code>checkState.put(keptIds);//keptIds类型为JSONArray
</code></pre><p>最终在mysql中,keptIds这一column显示的值是‘Array’，没错，字符串‘Array’，显然，信息丢失了。</p>
<p>目前的数据都是String类型，发现也是最好操作的。包括，python例子中的imgjson它存到数据库中就是一个字符串。</p>
<p><strong>总之，为了在网络上传递复杂的数据类型，json用统一的格式来组织数据，并以字符的形式在网络上进行传输，就像是一种中间表达，沟通客户端与服务端的数据表达。</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>写爬虫的时候真的发现json很好用，作为一种序列化机制。。。恐怕没有更好理解的了。</p>
<p>这里我的数据经历了：</p>
<p><strong>网站–&gt;python爬虫–&gt;mysql数据库&lt;–&gt;php程序&lt;–&gt;java(安卓app)</strong></p>]]>
    
    </summary>
    
      <category term="java" scheme="http://potatoker.github.io/tags/java/"/>
    
      <category term="json" scheme="http://potatoker.github.io/tags/json/"/>
    
      <category term="php" scheme="http://potatoker.github.io/tags/php/"/>
    
      <category term="python" scheme="http://potatoker.github.io/tags/python/"/>
    
      <category term="general tech" scheme="http://potatoker.github.io/categories/general-tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[are you ok]]></title>
    <link href="http://potatoker.github.io/2015/12/13/are-you-ok/"/>
    <id>http://potatoker.github.io/2015/12/13/are-you-ok/</id>
    <published>2015-12-13T08:03:20.000Z</published>
    <updated>2015-12-13T08:27:21.993Z</updated>
    <content type="html"><![CDATA[<p>总算是要准备开始写博客了！</p>
<p>之前一直都是在用evernote当博客。。。</p>
<p>这边可以用markdown感觉以后可能会把这个博客当做笔记吧==</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>总算是要准备开始写博客了！</p>
<p>之前一直都是在用evernote当博客。。。</p>
<p>这边可以用markdown感觉以后可能会把这个博客当做笔记吧==</p>
]]>
    </summary>
    
      <category term="helo, blog" scheme="http://potatoker.github.io/tags/helo-blog/"/>
    
  </entry>
  
</feed>
